---
category: technology
title: Frontend Development Strategy
tags:
- frontend-development
- react-vue-angular
- responsive-design
- pwa
use_cases:
- Building production-ready web applications with modern JavaScript frameworks, responsive design, performance optimization, and accessibility
- Implementing Progressive Web Apps with offline support, service workers, and app-like experiences
- Creating component libraries and design systems following atomic design principles with comprehensive testing
related_templates:
- technology/architecture-design.md
- technology/testing-qa.md
- design/ux-ui-design-comprehensive.md
industries:
- manufacturing
- technology
type: framework
difficulty: comprehensive
slug: frontend-development
---

# Frontend Development Strategy

## Purpose
Design and implement modern frontend web applications with component-based frameworks, responsive design, performance optimization (Lighthouse >90), accessibility compliance (WCAG AA), and comprehensive testing achieving production-ready quality.

## ðŸš€ Quick Frontend Development Prompt

> Build **[APPLICATION_TYPE]** using **[FRAMEWORK]** (React/Vue/Angular) with TypeScript targeting **[LIGHTHOUSE_SCORE]** Lighthouse score. Stack: (1) **UI**â€”what component library (Material-UI/Tailwind/Chakra), design system (atomic design), theme support (dark mode)? (2) **State**â€”what management (Redux/Zustand/Pinia), API client (React Query/SWR), caching strategy (stale-while-revalidate)? (3) **Performance**â€”what Core Web Vitals targets (LCP <2.5s, FID <100ms), optimization strategies (code splitting, lazy loading, image optimization)? (4) **Accessibility**â€”what compliance level (WCAG AA/AAA), keyboard navigation, screen reader support, color contrast (4.5:1)? (5) **Testing**â€”what coverage (80% unit, E2E critical paths), tools (Vitest/Playwright), CI integration? Deliver component library, responsive layouts, deployment configuration, monitoring setup.

---

## Template

Develop {APPLICATION_TYPE} using {FRAMEWORK} targeting {USER_BASE} users with {PERFORMANCE_SCORE} Lighthouse score achieving {ACCESSIBILITY_LEVEL} compliance deployed to {HOSTING_PLATFORM}.

**FRAMEWORK SELECTION AND ARCHITECTURE**

Choose framework matching team expertise, application requirements, and ecosystem maturity. React 18 dominates market share providing largest ecosystem: hooks for state management (useState, useEffect, useContext enabling reusable logic), virtual DOM reconciliation (efficient updates comparing trees, batching DOM changes), component composition (reusable building blocks, prop drilling or context for data flow), extensive third-party libraries (React Query for server state, React Router for navigation, thousands of npm packages). Next.js extends React with server-side rendering (SSR generating HTML server-side improving SEO and first paint), static site generation (SSG pre-rendering pages at build time, incremental static regeneration updating without full rebuild), API routes (serverless functions in same codebase, middleware for auth/logging), file-based routing (pages directory maps to URLs automatically), image optimization (next/image component automatically serving WebP, responsive images, lazy loading).

Vue 3 offers gentle learning curve with progressive adoption: composition API (setup() function organizing logic by feature not lifecycle, ref/reactive for reactivity), template syntax (HTML-like templates familiar to designers, directives v-if/v-for/v-model), single-file components (template, script, style colocated in .vue files), reactivity system (Proxy-based dependency tracking, automatic updates on data changes), excellent documentation and official libraries (Vue Router, Pinia state management, Nuxt for SSR). Nuxt 3 provides full-stack framework: auto-imports (components, composables, utils imported automatically), server routes (API endpoints in server directory), hybrid rendering (per-route SSR/SSG configuration), module ecosystem (authentication, PWA, content management).

Angular 17 suits enterprise applications requiring opinionated structure: TypeScript-first (strong typing, decorators, dependency injection), comprehensive framework (routing, HTTP client, forms, testing built-in), RxJS observables (reactive programming for async operations, powerful operators for data transformation), signals for reactivity (fine-grained reactivity replacing zone.js, improved performance), CLI scaffolding (ng generate creating components/services/modules, consistent project structure), standalone components (simplified architecture without NgModules). Organizations with Java/.NET backgrounds favor Angular's familiar patterns (dependency injection, decorators, enterprise patterns).

Design component architecture using atomic design principles. Atoms represent basic building blocks: buttons (primary, secondary, outline variants with size options small/medium/large, loading states, disabled states), inputs (text, email, password, number with validation states, error messages, helper text), typography (heading levels h1-h6, body text, captions with responsive scaling, accessible contrast), icons (consistent set from library like Heroicons, Lucide, optimized SVGs <5KB). Molecules combine atoms into functional units: form fields (input + label + error message grouped, consistent spacing), cards (container + header + body + footer sections, elevation shadows, interactive hover states), navigation items (link + icon + badge combining multiple atoms, active state highlighting). Organisms create complex sections: headers (logo + navigation + search + user menu, responsive hamburger on mobile), data tables (columns + rows + sorting + filtering + pagination, virtual scrolling for 10K+ rows), forms (field groups + validation + submission handling, multi-step wizards). Templates define page layouts: landing pages (hero + features + testimonials + CTA sections), admin dashboards (sidebar + header + content area + footer, widget grid), authentication flows (centered card layout, social login buttons, form validation).

**STATE MANAGEMENT AND DATA FETCHING**

Implement state management separating concerns by type. Client state handles UI and local data: React useState for component-local state (modal open/closed, form input values, selected items), useReducer for complex state logic (shopping cart with add/remove/update/clear actions, form with validation and submission states), Context API for global UI state (theme preference, language selection, sidebar collapsed state avoiding prop drilling). Redux Toolkit reduces boilerplate for complex applications: createSlice defining reducers and actions together (user slice, products slice, cart slice organized by domain), Redux Thunk middleware for async operations (API calls dispatching pending/fulfilled/rejected actions), Redux DevTools time-travel debugging (inspect state changes, action history, replay actions). Zustand offers minimal alternative: create((set) => ({...})) defining store inline, no provider wrapping, small bundle size <1KB, middleware for persistence (localStorage sync), devtools integration.

Manage server state separately using specialized libraries. React Query caches server data automatically: useQuery hook fetching data (queryKey identifying cached data, queryFn performing fetch, automatic background refetch), stale-while-revalidate strategy (showing cached data immediately, fetching fresh in background), automatic retry on failure (exponential backoff 1s, 2s, 4s), query invalidation on mutations (POST/PUT/DELETE triggering refetch of related data), optimistic updates (updating cache before server response, rolling back on error). SWR provides similar capabilities: useSWR(key, fetcher) hook with automatic revalidation, focus revalidation (refetch when user returns to tab), interval polling (periodic refresh for real-time data), error retry with exponential backoff, local mutation for instant feedback. RTK Query integrates with Redux: createApi defining endpoints (queries for GET, mutations for POST/PUT/DELETE), automatic cache management, optimistic updates, polling support, code generation from OpenAPI specs.

Handle forms efficiently balancing controlled inputs with performance. React Hook Form minimizes re-renders: register() connecting inputs to form state (validation rules inline, ref-based avoiding controlled inputs), handleSubmit processing valid data, errors object with field-level messages, watch() for conditional fields, setValue() programmatic updates. Zod or Yup schema validation: define type-safe schemas (z.object({ email: z.string().email(), age: z.number().min(18) })), resolver integration with React Hook Form, reusable schemas across frontend/backend, type inference for TypeScript. Formik alternative for complex forms: useFormik hook managing values/errors/touched, Field components with built-in validation, FieldArray for dynamic lists (add/remove form rows).

**PERFORMANCE OPTIMIZATION AND CORE WEB VITALS**

Optimize Core Web Vitals meeting Google ranking requirements. Largest Contentful Paint (LCP) measures loading performance targeting <2.5s: optimize hero images (serve WebP/AVIF format 30% smaller, responsive images via srcset providing appropriate size, priority loading with fetchpriority="high"), preload critical resources (<link rel="preload"> for fonts, hero images, critical CSS), server-side rendering (Next.js/Nuxt generating HTML server-side, faster first paint versus client-only rendering), CDN distribution (CloudFront, Cloudflare serving assets from edge locations reducing latency 50-100ms). First Input Delay (FID) measures interactivity targeting <100ms: code splitting by route (dynamic imports loading pages on-demand, reducing initial bundle 60-80%), defer non-critical JavaScript (async/defer attributes, third-party scripts loaded after interactive), break up long tasks (splitting CPU-intensive work into chunks with requestIdleCallback, web workers for heavy computation), reduce JavaScript execution (tree-shaking removing unused code, minification reducing bundle size 30-40%).

Implement Cumulative Layout Shift (CLS) prevention targeting <0.1: specify image dimensions (width/height attributes reserving space, preventing layout jump when loaded), avoid inserting content above existing (loading indicators in reserved space, ads with fixed containers), use CSS transform for animations (transform/opacity don't trigger layout, versus top/left causing reflow), font loading strategy (font-display: swap showing fallback immediately, preload fonts to reduce flash). Monitor using Real User Monitoring: web-vitals library reporting metrics to analytics, Chrome User Experience Report showing field data, Lighthouse CI blocking deploys exceeding budgets.

Optimize bundle size reducing parse and download time. Code splitting separates bundles: route-based splitting (React.lazy(() => import('./Page')) loading page on navigation, Suspense boundary with fallback), vendor chunking (separating node_modules into vendor bundle, caching separately from app code), dynamic imports for heavy features (import('./Editor').then() loading rich text editor only when needed). Tree shaking eliminates dead code: ES modules enabling static analysis (import/export versus require), side-effect-free code (avoid module-level execution, mark sideEffects: false in package.json), unused exports removed by bundler (Rollup, Webpack, Vite analyzing import graph). Image optimization reduces largest assets: WebP format (30% smaller than JPEG, 26% smaller than PNG, 95%+ browser support with JPEG fallback), responsive images (srcset providing 1x/2x/3x variants, sizes attribute indicating display size, browser selecting optimal), lazy loading (loading="lazy" deferring below-fold images, intersection observer for custom logic), image CDN (Cloudinary, Imgix generating optimized variants on-demand).

**ACCESSIBILITY IMPLEMENTATION AND WCAG COMPLIANCE**

Implement keyboard navigation enabling non-mouse interaction. Tab order follows logical reading flow: interactive elements (links, buttons, inputs) focusable by default, tabindex="0" adding custom elements to tab order, tabindex="-1" removing from tab order (off-screen elements, managed focus components), avoid tabindex >0 (disrupts natural order, confuses users). Focus management in SPAs: route changes move focus to heading (document.querySelector('h1').focus() announcing page change to screen readers), modal dialogs trap focus (cycling tab within modal, returning to trigger on close), skip links bypass navigation (hidden link to main content, visible on focus, keyboard users jump to content). Keyboard shortcuts accelerate power users: common patterns (Ctrl+S save, Ctrl+K search, Escape close), Mousetrap or custom hooks for shortcuts, avoid conflicts with browser/screen reader shortcuts, provide visible reference (? key showing shortcut list).

Support screen readers announcing content and interactions. Semantic HTML provides automatic structure: headings (h1-h6 hierarchical outline, unique h1 per page, logical nesting), landmarks (main, nav, aside, footer regions), lists (ul/ol for grouped items, screen readers announcing "list 5 items"), buttons versus links (buttons for actions, links for navigation, role="button" for custom buttons). ARIA attributes enhance semantics where HTML insufficient: aria-label describing elements without text (icon buttons, decorative images), aria-labelledby referencing visible label, aria-describedby providing additional context (error messages, help text), aria-live announcing dynamic updates (role="status" for polite announcements, role="alert" for urgent). Manage focus and state announcements: aria-expanded on toggles (true/false announcing dropdown state), aria-selected in tabs/listboxes, aria-checked for custom checkboxes, aria-hidden hiding decorative elements (icon accompanying text label).

Ensure color contrast meeting WCAG requirements. WCAG AA requires minimum ratios: normal text 4.5:1 contrast (#000 on #fff = 21:1 maximum, #767676 on #fff = 4.5:1 minimum), large text 3:1 (18pt+, 14pt+ bold), UI components 3:1 (buttons, form borders, focus indicators). Check contrast programmatically: WebAIM contrast checker, axe DevTools browser extension, build-time checks with Pa11y. Don't rely solely on color: success/error indicated by icon + text (not just green/red), required fields marked with asterisk + label, chart data distinguishable by pattern + color. Provide high contrast theme: prefers-contrast-more media query detecting OS preference, user toggle storing preference, increased contrast borders and shadows.

**TESTING STRATEGY AND QUALITY ASSURANCE**

Structure testing pyramid balancing speed and confidence. Unit tests form foundation (70% of suite): testing hooks (React Testing Library renderHook, act for state updates), utility functions (pure functions easily testable, edge cases covered), validation logic (schema validation, business rules), running in <30 seconds providing immediate feedback. Component tests verify rendering and interaction (20% of suite): React Testing Library focusing user behavior (screen.getByRole('button'), userEvent.click simulating interactions), avoid implementation details (not testing state directly, test what users see), Storybook interaction tests (play functions simulating user flows, addons for a11y/viewport testing). Integration tests validate workflows (10% of suite): multi-component interactions (form submission updating list, cart adding items updating total), API mocking with MSW (mock service worker intercepting requests, returning test data, testing error states), Testing Library rendering full page components (not isolated units).

Implement end-to-end testing covering critical user journeys. Playwright enables cross-browser testing: tests run in Chromium, Firefox, WebKit (covering Chrome, Edge, Safari), parallel execution reducing 30-minute suite to 5 minutes, auto-wait (no manual sleeps, waiting for elements to appear/be clickable), network interception (mocking APIs, testing offline scenarios), screenshot/video on failure (debugging flaky tests). Cypress provides excellent developer experience: time-travel debugging (seeing DOM at each step), automatic retries (reducing flakiness), real browser execution (not headless only), component testing (mounting React components in isolation). Test critical paths only E2E: authentication (login, registration, password reset preventing lockout), checkout (add to cart, apply discount, payment, confirmation ensuring revenue), admin functions (user management, content publishing, configuration preventing data loss).

Integrate visual regression testing catching unintended UI changes. Chromatic for Storybook: baseline screenshots of all stories, pull requests compared to baseline, visual diff highlighting pixel changes, UI Review workflow (approve intentional changes, reject regressions). Percy for full pages: snapshot testing entire pages, responsive testing (mobile, tablet, desktop variants), CSS animation handling, integrates with CI (GitHub Actions, CircleCI). Playwright visual comparisons: page.screenshot() capturing current state, pixelmatch comparing to baseline, storing screenshots in repository or external storage, threshold tolerance for anti-aliasing differences.

**BUILD OPTIMIZATION AND DEPLOYMENT**

Configure build tools balancing development experience with production performance. Vite provides instant dev server: native ES modules in development (no bundling, instant HMR), esbuild pre-bundling dependencies (30x faster than Webpack), Rollup production builds (optimized bundles, tree-shaking), plugin ecosystem (Vue, React, Svelte support). Webpack 5 offers mature ecosystem: extensive loaders and plugins, code splitting strategies, module federation (sharing code between separately deployed apps), persistent caching (faster rebuild times). Configure optimization: TerserPlugin minifying JavaScript, CssMinimizerPlugin optimizing CSS, html-webpack-plugin generating HTML with hashed assets, compression plugins (gzip, brotli reducing bundle 70-80%).

Implement deployment strategies minimizing risk. Static hosting for JAMstack: Vercel for Next.js (automatic previews per PR, edge functions, image optimization), Netlify for any static site (form handling, serverless functions, split testing), CloudFront + S3 (custom CDN configuration, Lambda@Edge for headers), GitHub Pages for open source (free hosting, custom domains). Container deployment for complex apps: Docker multi-stage builds (build stage with node:18, production stage with node:18-alpine reducing image 70%), Kubernetes horizontal scaling (replica sets, auto-scaling based on CPU), health checks (readiness probe /health, liveness probe preventing restart loops). Blue-green deployment preventing downtime: maintain two environments (blue currently serving traffic, green receiving new deployment), smoke test green environment, switch load balancer to green, blue remains for instant rollback.

Monitor production performance and errors. Real User Monitoring tracks actual user experience: web-vitals library measuring Core Web Vitals, reportWebVitals sending to analytics, Google Analytics 4 tracking engagement, custom events for business metrics. Error tracking catches JavaScript exceptions: Sentry capturing errors (stack traces, breadcrumbs showing user actions before error, release tracking identifying regressions), source map upload (un-minifying production errors, pointing to original code lines), error grouping (similar errors combined, prioritizing high-volume issues), alerts (Slack/email for new errors, spike detection). Performance monitoring identifies bottlenecks: Datadog RUM tracking page load times, bundle size monitoring (build-time checks failing if bundle exceeds budget), Lighthouse CI on every deploy (blocking merge if score drops below 90).

Deliver frontend application as:

1. **COMPONENT LIBRARY** - Reusable components following atomic design (atoms, molecules, organisms), Storybook documentation, TypeScript types, unit tests achieving 80%+ coverage

2. **RESPONSIVE LAYOUTS** - Mobile-first designs with breakpoints (320px, 768px, 1024px, 1440px), flexible grids, touch-optimized interactions, print stylesheets

3. **STATE MANAGEMENT** - Redux/Zustand store configuration, API client setup (React Query/SWR), caching strategies, optimistic updates, error boundaries

4. **PERFORMANCE OPTIMIZATION** - Code splitting configuration, lazy loading, image optimization, Core Web Vitals monitoring, bundle size budgets (<200KB gzipped)

5. **ACCESSIBILITY COMPLIANCE** - WCAG AA checklist verified, keyboard navigation, screen reader testing (VoiceOver, NVDA), color contrast validation, ARIA labels

6. **DEPLOYMENT PIPELINE** - CI/CD configuration (GitHub Actions, CircleCI), build optimization, environment configuration, monitoring setup (Sentry, Analytics), rollback procedures

---

## Usage Examples

### Example 1: E-commerce SPA (React + Next.js)
**Prompt:** Build e-commerce SPA for ShopNow serving 100K monthly users using React 18 + Next.js 14 targeting 95+ Lighthouse score with WCAG AA compliance deployed to Vercel.

**Expected Output:** Framework architecture: Next.js 14 App Router (file-based routing in app directory, server components by default reducing client bundle 40%, client components marked with 'use client'), React 18 with Suspense (streaming SSR showing UI progressively, skeleton fallback during fetch), TypeScript strict mode (noImplicitAny, strictNullChecks preventing runtime errors). Component library (150+ components): Atoms include Button component (variants: primary, secondary, outline, ghost using Tailwind variants, sizes: sm/md/lg, loading state with spinner, disabled state with reduced opacity, icon support), Input component (types: text/email/password/number, validation states error/success, aria-describedby connecting to error message, controlled via React Hook Form). Molecules include ProductCard (image with next/image optimization, title/price/rating, add-to-cart button, hover effect with scale transform), SearchBar (autocomplete using Downshift, debounced API calls, keyboard navigation, recent searches). Organisms include Header (logo, navigation menu, search, cart icon with badge, user menu dropdown, mobile hamburger), ProductGrid (responsive grid 1/2/3/4 columns based on breakpoint, infinite scroll using intersection observer, skeleton loading), Checkout wizard (multi-step form, step indicator, validation per step, progress save to localStorage). State management: Redux Toolkit store with slices (authSlice managing user/token, cartSlice with add/remove/updateQuantity, productsSlice caching product list), RTK Query for API (endpoints: getProducts, getProduct, createOrder, mutations invalidating cache), Redux persist (auth and cart to localStorage, migration for schema changes). Performance optimizations: Code splitting per route (dynamic imports for checkout, admin, profile pages loaded on navigation), lazy loading images (below-fold products with loading="lazy", priority for hero banner), font optimization (next/font/google preloading Inter font, font-display: swap preventing layout shift), bundle analysis (webpack-bundle-analyzer showing lodash tree-shakeable, removing moment.js saving 65KB switching to date-fns). Core Web Vitals: LCP 1.8s (hero image WebP format, priority loading, CDN delivery via Vercel), FID 45ms (code splitting reducing main bundle to 120KB, no blocking scripts), CLS 0.05 (image dimensions specified, skeleton loaders reserving space, no content insertion above fold). Accessibility: WCAG AA compliance verified with axe DevTools (0 violations), keyboard navigation (skip link to main content, focus trap in modal dialogs, Enter/Space activating buttons), screen reader support (product announcements with aria-live="polite", ARIA labels on icon buttons, form error announcements), color contrast 4.5:1 minimum (text colors verified with WebAIM checker, error messages have icon + text not just red color). Testing: Unit tests 85% coverage (Vitest + React Testing Library, utilities and hooks tested, custom matchers for common assertions), component tests in Storybook (interaction tests for forms, visual regression with Chromatic catching styling bugs), E2E tests (Playwright covering login, product search, add to cart, checkout flow, payment integration with Stripe test mode, 8 critical paths in 6-minute suite). Deployment: Vercel deployment (automatic preview deployments per PR, production deployment on main merge, edge functions for personalization), environment variables (NEXT_PUBLIC_API_URL, STRIPE_PUBLIC_KEY, Analytics tracking IDs), monitoring (Sentry error tracking <0.1% error rate SLA, Google Analytics 4 conversion tracking, Vercel Analytics for Web Vitals). Dependencies: next@14.0.4, react@18.2.0, @reduxjs/toolkit@2.0.1, tailwindcss@3.4.0, react-hook-form@7.49.0, zod@3.22.4 for validation, @tanstack/react-query@5.17.0 alternative to RTK Query, vitest@1.1.0, playwright@1.40.0. Performance benchmarks: Lighthouse score 96 (performance 95, accessibility 100, best practices 100, SEO 92), bundle size 145KB gzipped (within 200KB budget), LCP 1.8s / FID 38ms / CLS 0.04 all passing thresholds, time to interactive 2.1s.

### Example 2: Enterprise Dashboard (Angular + NgRx)
**Prompt:** Build enterprise analytics dashboard for DataCorp serving 5K employees using Angular 17 + NgRx targeting real-time data visualization with WCAG AAA critical paths.

**Expected Output:** Framework architecture: Angular 17 standalone components (no NgModules, simplified architecture, tree-shakeable imports), signals for reactivity (toSignal converting observables to signals, computed for derived state, effect for side effects), RxJS for async operations (observables for WebSocket streams, operators for data transformation, shareReplay caching HTTP responses). Component structure: DashboardShell (sidebar navigation, header with user menu, main content area with router-outlet, responsive collapsible sidebar), MetricCard (displays KPI with trend indicator, chart preview, click expands to detailed view, skeleton loading state), DataTable (ag-Grid integration for 100K+ rows, virtual scrolling, column sorting/filtering, CSV export, cell renderers for formatting), ChartWidget (Chart.js wrapper, responsive sizing, theme-aware colors, accessibility via data table alternative). State management: NgRx store with feature states (auth feature managing user permissions, dashboard feature with widget configurations, data feature caching API responses), effects for async operations (loadMetrics$ effect triggering HTTP request, WebSocket effect for real-time updates, error handling with catchError), selectors with memoization (selectTopRevenue combining multiple slices, reselect preventing recalculation, parameterized selectors for filtered data). Real-time updates: WebSocket connection using socket.io-client (connection on login, auto-reconnect on disconnect, room-based subscriptions for relevant data), SignalR alternative for .NET backend (TypeScript client, hub connection, server push updates), polling fallback (30-second interval when WebSocket unavailable, exponential backoff on errors). Data visualization: D3.js for custom charts (force-directed network graph, hierarchical tree, geographic map with projections), Chart.js for standard charts (line, bar, pie with responsive options, plugins for annotations), Plotly for scientific visualization (3D surface plots, heatmaps, statistical distributions), accessibility (data table alternative for all charts, keyboard navigation through data points, screen reader announcements for updates). Performance optimizations: OnPush change detection (markForCheck only when inputs change, reducing change detection cycles 90%), trackBy functions in ngFor (preventing DOM recreation on data updates), lazy loading modules (feature modules loaded on route activation, preloading strategy for likely routes), virtual scrolling for lists (cdk-virtual-scroll-viewport rendering only visible items, 10K items rendering at 60fps). Accessibility: WCAG AAA for critical analytics (7:1 contrast for dashboard text, keyboard shortcuts documented, screen reader optimized table navigation), ARIA live regions (chart updates announced politely, error alerts announced assertively), high contrast mode (media query prefers-contrast-more, alternative theme with bolder colors and borders), focus management (route changes announce new page title, modal focus trap, skip links to main charts). Testing: Jasmine + Karma for unit tests (90% coverage, TestBed for component testing, HttpClientTestingModule mocking HTTP), Cypress for E2E (login flow, dashboard navigation, filter interactions, export functionality, 15-minute regression suite), visual testing (Percy snapshots for dashboard layouts, responsive testing at 5 breakpoints). Build and deployment: Nx monorepo (dashboard, component library, utilities as separate projects, affected commands testing only changed code), Angular CLI production build (ahead-of-time compilation, tree-shaking, budget warnings at 500KB), Azure deployment (Static Web Apps for frontend, SignalR service for WebSocket, Application Insights monitoring), environment configuration (prod/staging/dev environments, feature flags via LaunchDarkly). Dependencies: @angular/core@17.0.8, @ngrx/store@17.0.1, @ngrx/effects@17.0.1, chart.js@4.4.1, d3@7.8.5, socket.io-client@4.6.1, ag-grid-angular@31.0.1, @angular/cdk@17.0.4 for virtual scrolling, cypress@13.6.2, @nx/angular@17.2.0. Performance: Initial bundle 245KB gzipped (dashboard lazy loaded separately 180KB), time to interactive 2.8s on 3G, chart rendering 10K points in <100ms, WebSocket latency <50ms.

### Example 3: Marketing Landing Page (Vue 3 + Nuxt)
**Prompt:** Build marketing landing page for LaunchPad targeting <2s load time with server-side rendering for SEO using Vue 3 + Nuxt 3 deployed to Netlify Edge.

**Expected Output:** Framework architecture: Nuxt 3 with server-side rendering (SSR generating HTML on Netlify Edge Functions, faster first contentful paint 0.8s versus 2.5s CSR), static site generation (SSG pre-rendering at build time for fully static content, incremental static regeneration for blog posts), hybrid rendering (homepage SSR for dynamic content, about page SSG for static content, per-route configuration). Component structure: HeroSection (full-viewport height, background video or animated gradient, headline with typewriter effect, CTA buttons, scroll indicator), FeatureGrid (responsive 1/2/3 columns, icon + title + description, hover animations with GSAP), TestimonialCarousel (Swiper.js integration, auto-play with pause on hover, pagination dots, swipe gestures on mobile), PricingTable (comparison grid, highlighted recommended plan, toggle annual/monthly billing, smooth height transition), NewsletterSignup (email input with validation, Mailchimp API integration, success/error toast notifications). Animations: GSAP for scroll-triggered animations (ScrollTrigger revealing sections on scroll, parallax backgrounds, smooth scrubbing), Lottie for vector animations (exported from After Effects, interactive JSON animations, lightweight <50KB), CSS animations for micro-interactions (button hover states, loading spinners, skeleton screens). Content management: Nuxt Content module (markdown files in content directory, auto-generated routes, component syntax in markdown, meta frontmatter for SEO), Strapi headless CMS alternative (GraphQL API, media library, role-based access, content versioning), git-based CMS (Netlify CMS, TinaCMS editing markdown files). SEO optimization: Meta tags (useHead composable setting title, description, Open Graph tags), structured data (JSON-LD schema for Organization, Product, Article improving rich snippets), sitemap generation (auto-generated from routes, submitted to Google Search Console), canonical URLs (preventing duplicate content), robots.txt (allowing all crawlers). Performance optimizations: Image optimization (Nuxt Image module generating WebP/AVIF, responsive srcset, lazy loading, blur placeholder during load), font loading strategy (Google Fonts with font-display: swap, preconnect to fonts.gstatic.com, font subsetting for used glyphs only), critical CSS inlining (above-fold styles in <head>, async loading full CSS), prefetching (nuxt-link prefetching linked pages on hover, preload critical assets). Core Web Vitals: LCP 1.2s (hero image optimized WebP, priority loading, edge caching), FID 25ms (minimal JavaScript, code splitting per page, defer analytics), CLS 0.02 (aspect ratio boxes for images, no layout shift on font load). Analytics and tracking: Google Analytics 4 (gtag integration via Nuxt plugin, page view tracking, custom events for CTA clicks), Hotjar for heatmaps (scroll maps, click maps, session recordings, feedback widgets), Plausible alternative (privacy-friendly, GDPR compliant, lightweight <1KB script). A/B testing: LaunchDarkly feature flags (percentage rollout, user targeting, multi-variate testing), Netlify Edge Functions (edge-side A/B testing, no client-side flicker, server-rendered variants), Google Optimize (visual editor, integration with Analytics, statistical significance calculation). Deployment: Netlify deployment (GitHub integration, automatic deploys on push, preview deployments per PR, edge functions for SSR), environment variables (NUXT_PUBLIC_API_URL, MAILCHIMP_API_KEY, GA_TRACKING_ID in Netlify dashboard), custom domain (DNS configuration, automatic HTTPS via Let's Encrypt, CDN caching headers). Form handling: Netlify Forms (honeypot spam protection, email notifications, Zapier integration), Formspree alternative (reCAPTCHA integration, webhook forwarding, file upload support). Dependencies: nuxt@3.9.0, vue@3.4.3, @nuxtjs/tailwindcss@6.10.4, @nuxt/image@1.1.0, @nuxtjs/seo@2.0.0-rc.8, gsap@3.12.4, swiper@11.0.5, @vueuse/core@10.7.0 for composables. Performance benchmarks: Lighthouse 98 (performance 97, accessibility 100, best practices 100, SEO 100), load time 1.8s on 3G, FCP 0.9s, TTI 1.5s, bundle size 85KB gzipped.

---

## Cross-References

- [UX/UI Design](../../design/ux-ui-design-comprehensive.md) - Design systems, wireframing, user research informing component design
- [Testing and QA Strategy](testing-qa.md) - Testing pyramid, E2E strategies, visual regression testing approaches
- [Architecture Design](architecture-design.md) - System architecture patterns, API design, microservices integration
- [Code Generation](code-generation.md) - Component generation standards, TypeScript patterns, testing conventions
