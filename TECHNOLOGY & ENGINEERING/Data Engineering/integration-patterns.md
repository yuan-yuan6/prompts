# Integration Patterns Template

## Purpose
Design comprehensive integration patterns for APIs, messaging systems, event-driven architectures, data synchronization, and system interoperability with scalability, reliability, and maintainability considerations.

## Template Structure

### Integration Overview
- **Integration Name**: {integration_name}
- **Integration Type**: {integration_type}
- **Business Purpose**: {business_purpose}
- **Integration Scope**: {integration_scope}
- **Stakeholders**: {stakeholders}
- **Performance Requirements**: {performance_requirements}
- **Scalability Requirements**: {scalability_requirements}
- **Reliability Requirements**: {reliability_requirements}
- **Security Requirements**: {security_requirements}
- **Compliance Requirements**: {compliance_requirements}

### System Architecture
- **Source Systems**: {source_systems}
- **Target Systems**: {target_systems}
- **Integration Layer**: {integration_layer}
- **Middleware Components**: {middleware_components}
- **Communication Protocols**: {communication_protocols}
- **Data Formats**: {data_formats}
- **Message Patterns**: {message_patterns}
- **Integration Topology**: {integration_topology}
- **Network Architecture**: {network_architecture}
- **Security Architecture**: {security_architecture}

### API Integration Patterns
- **API Design Style**: {api_design_style}
- **API Protocol**: {api_protocol}
- **API Gateway**: {api_gateway}
- **Authentication Method**: {authentication_method}
- **Authorization Model**: {authorization_model}
- **Rate Limiting**: {rate_limiting}
- **API Versioning**: {api_versioning}
- **Request/Response Format**: {request_response_format}
- **Error Handling**: {api_error_handling}
- **Documentation Standard**: {documentation_standard}

### Messaging Patterns
- **Message Broker**: {message_broker}
- **Messaging Paradigm**: {messaging_paradigm}
- **Message Routing**: {message_routing}
- **Message Transformation**: {message_transformation}
- **Message Serialization**: {message_serialization}
- **Message Ordering**: {message_ordering}
- **Message Durability**: {message_durability}
- **Message Acknowledgment**: {message_acknowledgment}
- **Dead Letter Handling**: {dead_letter_handling}
- **Message Retention**: {message_retention}

### Event-Driven Architecture
- **Event Streaming Platform**: {event_streaming_platform}
- **Event Schema**: {event_schema}
- **Event Sourcing**: {event_sourcing}
- **Event Store**: {event_store}
- **Event Processing**: {event_processing}
- **Event Choreography**: {event_choreography}
- **Event Orchestration**: {event_orchestration}
- **Event Replay**: {event_replay}
- **Event Versioning**: {event_versioning}
- **Event Governance**: {event_governance}

### Data Synchronization
- **Synchronization Strategy**: {synchronization_strategy}
- **Data Consistency Model**: {data_consistency_model}
- **Conflict Resolution**: {conflict_resolution}
- **Change Data Capture**: {change_data_capture}
- **Replication Method**: {replication_method}
- **Sync Frequency**: {sync_frequency}
- **Data Validation**: {data_validation}
- **Error Recovery**: {error_recovery}
- **Monitoring**: {sync_monitoring}
- **Performance Optimization**: {sync_optimization}

### Enterprise Service Bus
- **ESB Platform**: {esb_platform}
- **Service Registry**: {service_registry}
- **Service Discovery**: {service_discovery}
- **Message Mediation**: {message_mediation}
- **Protocol Translation**: {protocol_translation}
- **Data Transformation**: {data_transformation}
- **Routing Logic**: {routing_logic}
- **Service Orchestration**: {service_orchestration}
- **Quality of Service**: {quality_of_service}
- **Governance Framework**: {governance_framework}

### Microservices Integration
- **Service Mesh**: {service_mesh}
- **Inter-Service Communication**: {inter_service_communication}
- **Service Discovery**: {microservice_discovery}
- **Load Balancing**: {load_balancing}
- **Circuit Breaker**: {circuit_breaker}
- **Bulkhead Pattern**: {bulkhead_pattern}
- **Saga Pattern**: {saga_pattern}
- **CQRS Pattern**: {cqrs_pattern}
- **API Gateway**: {microservice_gateway}
- **Service Monitoring**: {service_monitoring}

### Data Integration
- **ETL/ELT Strategy**: {etl_elt_strategy}
- **Data Pipeline**: {data_pipeline}
- **Data Mapping**: {data_mapping}
- **Schema Evolution**: {schema_evolution}
- **Data Quality**: {data_quality}
- **Master Data Management**: {master_data_management}
- **Data Catalog**: {data_catalog}
- **Data Lineage**: {data_lineage}
- **Metadata Management**: {metadata_management}
- **Data Governance**: {data_governance}

### Real-time Integration
- **Streaming Architecture**: {streaming_architecture}
- **Stream Processing**: {stream_processing}
- **Real-time Analytics**: {realtime_analytics}
- **Complex Event Processing**: {complex_event_processing}
- **Time Window Processing**: {time_window_processing}
- **State Management**: {state_management}
- **Backpressure Handling**: {backpressure_handling}
- **Fault Tolerance**: {fault_tolerance}
- **Exactly-Once Processing**: {exactly_once_processing}
- **Latency Requirements**: {latency_requirements}

### Batch Integration
- **Batch Processing Framework**: {batch_framework}
- **Job Scheduling**: {job_scheduling}
- **Batch Size Optimization**: {batch_size_optimization}
- **Parallel Processing**: {parallel_processing}
- **Error Handling**: {batch_error_handling}
- **Recovery Mechanisms**: {recovery_mechanisms}
- **Job Dependencies**: {job_dependencies}
- **Resource Management**: {resource_management}
- **Monitoring**: {batch_monitoring}
- **Performance Tuning**: {batch_tuning}

### File-Based Integration
- **File Transfer Protocol**: {file_transfer_protocol}
- **File Formats**: {file_formats}
- **File Processing**: {file_processing}
- **File Validation**: {file_validation}
- **File Encryption**: {file_encryption}
- **File Archiving**: {file_archiving}
- **Error Handling**: {file_error_handling}
- **Retry Mechanisms**: {file_retry_mechanisms}
- **Monitoring**: {file_monitoring}
- **Cleanup Procedures**: {cleanup_procedures}

### Database Integration
- **Database Connectivity**: {database_connectivity}
- **Connection Pooling**: {connection_pooling}
- **Transaction Management**: {transaction_management}
- **Data Replication**: {data_replication}
- **Change Tracking**: {change_tracking}
- **Stored Procedures**: {stored_procedures}
- **Query Optimization**: {query_optimization}
- **Error Handling**: {db_error_handling}
- **Performance Monitoring**: {db_performance_monitoring}
- **Security**: {db_security}

### Cloud Integration
- **Cloud Strategy**: {cloud_strategy}
- **Multi-Cloud Integration**: {multi_cloud_integration}
- **Hybrid Integration**: {hybrid_integration}
- **Cloud-Native Services**: {cloud_native_services}
- **Serverless Integration**: {serverless_integration}
- **Container Integration**: {container_integration}
- **Cloud Security**: {cloud_security}
- **Cost Optimization**: {cloud_cost_optimization}
- **Performance**: {cloud_performance}
- **Compliance**: {cloud_compliance}

### Security Integration
- **Authentication**: {integration_authentication}
- **Authorization**: {integration_authorization}
- **Data Encryption**: {integration_encryption}
- **Network Security**: {integration_network_security}
- **API Security**: {integration_api_security}
- **Message Security**: {message_security}
- **Identity Management**: {identity_management}
- **Key Management**: {key_management}
- **Audit Logging**: {integration_audit_logging}
- **Compliance Monitoring**: {integration_compliance_monitoring}

### Error Handling
- **Error Classification**: {error_classification}
- **Error Propagation**: {error_propagation}
- **Error Recovery**: {integration_error_recovery}
- **Compensation Actions**: {compensation_actions}
- **Circuit Breaker**: {integration_circuit_breaker}
- **Retry Strategies**: {retry_strategies}
- **Dead Letter Queues**: {integration_dead_letter_queues}
- **Error Logging**: {error_logging}
- **Alert Management**: {alert_management}
- **Escalation Procedures**: {escalation_procedures}

### Monitoring and Observability
- **Integration Monitoring**: {integration_monitoring}
- **Performance Metrics**: {performance_metrics}
- **Business Metrics**: {business_metrics}
- **Health Checks**: {health_checks}
- **Distributed Tracing**: {distributed_tracing}
- **Log Aggregation**: {log_aggregation}
- **Dashboard Design**: {monitoring_dashboard_design}
- **Alerting Strategy**: {alerting_strategy}
- **SLA Monitoring**: {sla_monitoring}
- **Capacity Planning**: {monitoring_capacity_planning}

### Testing Strategy
- **Integration Testing**: {integration_testing}
- **Contract Testing**: {contract_testing}
- **End-to-End Testing**: {integration_e2e_testing}
- **Performance Testing**: {integration_performance_testing}
- **Load Testing**: {integration_load_testing}
- **Chaos Testing**: {chaos_testing}
- **Mock Services**: {mock_services}
- **Test Data Management**: {integration_test_data}
- **Test Automation**: {integration_test_automation}
- **Test Environment**: {test_environment}

### Deployment and Operations
- **Deployment Strategy**: {integration_deployment_strategy}
- **CI/CD Pipeline**: {integration_cicd_pipeline}
- **Configuration Management**: {integration_config_management}
- **Environment Management**: {integration_environment_management}
- **Version Control**: {integration_version_control}
- **Release Management**: {integration_release_management}
- **Rollback Procedures**: {integration_rollback_procedures}
- **Operational Procedures**: {operational_procedures}
- **Support Model**: {support_model}
- **Documentation**: {integration_documentation}

## Prompt Template

Design comprehensive integration architecture for {integration_name} {integration_type} supporting {business_purpose} across {integration_scope}. Meet {performance_requirements} performance, {scalability_requirements} scalability, and {reliability_requirements} reliability requirements while ensuring {security_requirements} security and {compliance_requirements} compliance.

**System Architecture:**
- Integrate {source_systems} with {target_systems}
- Use {integration_layer} with {middleware_components}
- Implement {communication_protocols} and {data_formats}
- Apply {message_patterns} in {integration_topology}
- Configure {network_architecture} with {security_architecture}

**API Integration:**
- Design {api_design_style} APIs using {api_protocol}
- Deploy {api_gateway} with {authentication_method}
- Implement {authorization_model} and {rate_limiting}
- Support {api_versioning} with {request_response_format}
- Handle errors with {api_error_handling}

**Messaging Architecture:**
- Use {message_broker} for {messaging_paradigm}
- Implement {message_routing} and {message_transformation}
- Configure {message_serialization} with {message_ordering}
- Ensure {message_durability} and {message_acknowledgment}
- Handle failures with {dead_letter_handling}

**Event-Driven Processing:**
- Deploy {event_streaming_platform} with {event_schema}
- Implement {event_sourcing} using {event_store}
- Configure {event_processing} with {event_choreography}
- Support {event_replay} and {event_versioning}
- Govern with {event_governance}

**Data Synchronization:**
- Apply {synchronization_strategy} with {data_consistency_model}
- Handle conflicts with {conflict_resolution}
- Use {change_data_capture} for {replication_method}
- Schedule {sync_frequency} with {data_validation}
- Monitor with {sync_monitoring} and optimize {sync_optimization}

**Real-time Processing:**
- Implement {streaming_architecture} for {stream_processing}
- Enable {realtime_analytics} and {complex_event_processing}
- Configure {time_window_processing} with {state_management}
- Handle {backpressure_handling} and ensure {fault_tolerance}
- Achieve {exactly_once_processing} within {latency_requirements}

**Security Implementation:**
- Configure {integration_authentication} and {integration_authorization}
- Enable {integration_encryption} and {integration_network_security}
- Secure APIs with {integration_api_security} and messages with {message_security}
- Manage identities with {identity_management} and keys with {key_management}
- Log with {integration_audit_logging} and monitor {integration_compliance_monitoring}

**Error Handling:**
- Classify errors with {error_classification} and propagate with {error_propagation}
- Recover with {integration_error_recovery} and compensate with {compensation_actions}
- Implement {integration_circuit_breaker} with {retry_strategies}
- Use {integration_dead_letter_queues} and log with {error_logging}
- Alert with {alert_management} and escalate with {escalation_procedures}

**Monitoring Setup:**
- Track {performance_metrics} and {business_metrics}
- Implement {health_checks} and {distributed_tracing}
- Aggregate logs with {log_aggregation} and create {monitoring_dashboard_design}
- Configure {alerting_strategy} and monitor {sla_monitoring}
- Plan capacity with {monitoring_capacity_planning}

Please provide detailed architecture diagrams, implementation specifications, configuration examples, testing strategies, and operational procedures with specific recommendations for the target integration platform.

## Usage Examples

### E-commerce Order Management Integration
```
Design comprehensive integration architecture for OrderProcessingIntegration API and messaging integration supporting order fulfillment across e-commerce platform, inventory, payment, shipping systems. Meet <100ms API response performance, 10K TPS scalability, and 99.9% reliability requirements while ensuring PCI DSS security and SOX compliance.

System Architecture:
- Integrate React frontend, Node.js services with PostgreSQL, Redis, Stripe, FedEx systems
- Use Kong API Gateway integration layer with Kafka, Redis middleware components
- Implement REST, GraphQL, gRPC communication protocols and JSON, Avro data formats
- Apply request-reply, publish-subscribe message patterns in hub-and-spoke integration topology
- Configure microservices network architecture with zero-trust security architecture

API Integration:
- Design RESTful APIs using HTTP/1.1, HTTP/2 protocol
- Deploy Kong API Gateway with OAuth 2.0, JWT authentication method
- Implement RBAC authorization model and 1000 req/min per user rate limiting
- Support semantic api versioning with JSON request/response format
- Handle errors with structured error responses, retry logic api error handling

Event-Driven Processing:
- Deploy Apache Kafka event streaming platform with Avro event schema
- Implement event sourcing using MongoDB event store
- Configure stream processing with Kafka Streams event choreography
- Support 7-day event replay and backward-compatible event versioning
- Govern with schema registry, topic naming conventions event governance

Real-time Processing:
- Implement Kafka Streams streaming architecture for real-time stream processing
- Enable real-time inventory, pricing realtime analytics and order state complex event processing
- Configure 5-minute tumbling time window processing with in-memory state management
- Handle consumer lag backpressure handling and ensure at-least-once fault tolerance
- Achieve idempotent exactly once processing within <50ms latency requirements
```

### Financial Data Integration
```
Design comprehensive integration architecture for TradingDataIntegration batch and streaming integration supporting trading operations across market data, risk systems, regulatory reporting. Meet <10ms streaming latency performance, 100K msg/sec scalability, and 99.99% reliability requirements while ensuring SOX, MiFID II security and Basel III, CCAR compliance.

Messaging Architecture:
- Use Apache Kafka, IBM MQ message broker for publish-subscribe messaging paradigm
- Implement content-based message routing and real-time message transformation
- Configure Avro message serialization with partition-based message ordering
- Ensure persistent message durability and automatic message acknowledgment
- Handle failures with retry, dead letter queue dead letter handling

Data Synchronization:
- Apply real-time synchronization strategy with eventual data consistency model
- Handle trade breaks with last-writer-wins conflict resolution
- Use Debezium change data capture for log-based replication method
- Schedule continuous sync frequency with schema, business rule data validation
- Monitor with Prometheus sync monitoring and optimize with partitioning, caching sync optimization

Security Implementation:
- Configure mTLS, SAML integration authentication and attribute-based integration authorization
- Enable AES-256 integration encryption and network segmentation integration network security
- Secure APIs with OAuth 2.0, rate limiting integration api security and messages with end-to-end encryption message security
- Manage identities with Active Directory identity management and keys with HSM key management
- Log with comprehensive integration audit logging and monitor with SIEM integration compliance monitoring

Error Handling:
- Classify errors with business, technical, system error classification and propagate with circuit breaker error propagation
- Recover with automatic retry, manual intervention integration error recovery and compensate with reverse trade compensation actions
- Implement hystrix integration circuit breaker with exponential backoff retry strategies
- Use Kafka dead letter topics integration dead letter queues and log with structured error logging
- Alert with PagerDuty alert management and escalate with tiered support escalation procedures
```

## Best Practices

1. **Design for loose coupling and high cohesion**
2. **Implement comprehensive error handling and recovery**
3. **Use asynchronous messaging for scalability**
4. **Apply circuit breaker and bulkhead patterns**
5. **Implement proper monitoring and observability**
6. **Design for idempotency and exactly-once processing**
7. **Use event-driven architecture for real-time requirements**
8. **Implement proper security and compliance controls**
9. **Plan for schema evolution and backward compatibility**
10. **Test integration points thoroughly with realistic data**