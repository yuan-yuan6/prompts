---
category: technology
title: Code Review Strategy
tags:
- code-review
- pull-request
- code-quality
- static-analysis
use_cases:
- Conducting pull request reviews focusing on security vulnerabilities, performance bottlenecks, and code maintainability
- Performing security audits validating authentication, authorization, input validation, and OWASP Top 10 compliance
- Reviewing API implementations for REST compliance, error handling, versioning, and documentation completeness
related_templates:
- technology/architecture-design.md
- technology/testing-qa.md
- technology/code-generation.md
industries:
- manufacturing
- technology
type: framework
difficulty: comprehensive
slug: code-review
---

# Code Review Strategy

## Purpose
Conduct comprehensive code reviews evaluating security, performance, maintainability, test coverage, and adherence to standards providing constructive feedback prioritized by severity with actionable recommendations and positive reinforcement.

## ðŸš€ Quick Code Review Prompt

> Review **[MODULE/FEATURE]** in **[LANGUAGE/FRAMEWORK]** targeting **[REVIEW_FOCUS]** (security/performance/quality). Priorities: (1) **Security**â€”what OWASP Top 10 risks (SQL injection/XSS/auth bypass), input validation, encryption, sensitive data handling? (2) **Code quality**â€”what readability issues, complexity >10, duplication >5%, SOLID violations, test coverage <80%? (3) **Performance**â€”what algorithm complexity, N+1 queries, memory leaks, synchronous blocking calls? (4) **Standards**â€”what linting errors, type safety issues, documentation gaps, commit message quality? (5) **Testing**â€”what missing edge cases, integration test gaps, mock usage, flaky tests? Deliver issues by severity (critical/major/minor), specific code examples, suggested fixes, positive highlights.

---

## Template

Review {MODULE} in {PROJECT} written in {LANGUAGE} using {FRAMEWORK} focusing on {REVIEW_PRIORITY} concerns targeting {TEST_COVERAGE}% coverage with {APPROVAL_CRITERIA} quality gates.

**SECURITY VULNERABILITY ASSESSMENT**

Validate input sanitization preventing injection attacks at every boundary. SQL injection prevention requires parameterized queries exclusively: prepared statements binding user input as parameters (PreparedStatement in Java, $1 placeholders in PostgreSQL, ? in SQLite), ORM query builders (SQLAlchemy filter(), Prisma where(), TypeORM QueryBuilder) parameterize automatically, never concatenate user input into SQL strings (dangerous: "SELECT * FROM users WHERE id = " + userId, safe: "SELECT * FROM users WHERE id = ?" with [userId] parameter). Check all database operations: dynamic filters, search queries, sorting parameters, pagination offsets. XSS prevention through context-appropriate encoding: HTML entity encoding for display (<script> becomes &lt;script&gt;), JavaScript encoding for script contexts (escaping quotes and special characters), URL encoding for href attributes, Content Security Policy headers blocking inline scripts, framework auto-escaping (React JSX, Vue templates, Angular templates default safe). Review user-generated content rendering: comments, profile data, markdown rendering, rich text editors.

Verify authentication and authorization implementation security. JWT token security requires proper configuration: RS256 asymmetric signing (public key verifies, private key signs preventing forgery), short-lived access tokens (15 minutes reducing compromise window), rotating refresh tokens (one-time use, new token issued on refresh), payload claims validated (expiration, issuer, audience), secret keys stored in environment variables or vault (never hardcoded). Check token handling: transmitted via Authorization: Bearer header (not query parameters exposing in logs), httpOnly secure cookies for browser clients preventing XSS theft, token invalidation on logout, expired token rejection with 401 Unauthorized. Authorization enforcement at multiple layers: API gateway validates permissions, service layer checks resource ownership, database row-level security policies, frontend hides UI but never trusts client-side checks. Review RBAC implementation: roles assigned to users, permissions checked before operations, hierarchical roles (admin inherits manager permissions), attribute-based policies for complex rules (OPA evaluating user department, resource sensitivity, time-of-day).

Assess sensitive data handling preventing exposure. Encryption at rest using AES-256: PII encrypted before database storage (SSN, credit cards, health records), customer-managed keys rotated quarterly (AWS KMS, Azure Key Vault, HashiCorp Vault), initialization vectors unique per operation, key derivation functions for password-based encryption (Argon2, PBKDF2 not MD5). Password hashing with bcrypt or Argon2: bcrypt work factor 12+ (100ms computation slowing brute force), unique salts per password (generated automatically, stored with hash), timing-safe comparison preventing timing attacks (compare_digest in Python, crypto.timingSafeEqual in Node.js). Check secret management: API keys in environment variables or vault, no secrets in version control (git-secrets preventing commits), secrets rotated on exposure, minimal scope for service accounts. Review logging security: passwords never logged, PII masked or excluded, error messages generic to users (detailed logs internal only), stack traces not exposed in API responses.

Identify OWASP Top 10 vulnerabilities requiring immediate remediation. Broken access control: vertical privilege escalation (regular user accessing admin functions), horizontal privilege escalation (user A accessing user B resources), insecure direct object references (expose internal IDs, use UUIDs or check ownership), missing function-level access control (API endpoints lack authorization). Cryptographic failures: weak algorithms (MD5, SHA1 deprecated), insufficient key length (RSA <2048 bits), hardcoded secrets, unencrypted sensitive data transmission. Injection flaws: SQL injection, NoSQL injection (MongoDB $where operator misuse), OS command injection (shell=True with user input), LDAP injection. Security misconfiguration: default credentials unchanged, unnecessary features enabled, verbose error messages, missing security headers (HSTS, X-Content-Type-Options, X-Frame-Options). Vulnerable components: outdated dependencies (npm audit, Snyk finding CVEs), unpatched frameworks, end-of-life libraries.

**CODE QUALITY AND MAINTAINABILITY REVIEW**

Evaluate code complexity identifying refactoring opportunities. Cyclomatic complexity measures decision points: <10 acceptable (simple logic), 10-20 concerning (consider decomposition), >20 critical (extract methods, simplify conditionals). Calculate complexity: count if/else branches, case statements, loops, logical operators (&&, ||), ternary operators, early returns. Address high complexity through extraction: long functions split into smaller focused functions (<50 lines each), nested conditionals flattened (early returns, guard clauses), switch statements replaced with polymorphism or strategy pattern (payment method selection via PaymentProcessor interface instead of switch). Cognitive complexity assesses understandability: nested conditions increase complexity non-linearly, breaks in control flow (exceptions, recursion) add complexity, similar-looking code blocks decrease it. Target cognitive complexity <15 for maintainability.

Check SOLID principles adherence ensuring extensible design. Single Responsibility: each class one reason to change (UserService handles business logic only, UserRepository data access only, UserValidator input validation only), large classes indicate multiple responsibilities requiring decomposition, methods within class relate to single concern. Open/Closed: extend behavior without modification (new payment methods add PaymentProcessor implementations not modify switch statement), dependency injection enables swapping implementations (IEmailService interface with SmtpEmailService, SendGridEmailService implementations), decorators add functionality without changing core (CachedUserRepository wrapping DatabaseUserRepository). Liskov Substitution: subclasses work wherever parent expected (Square inheriting Rectangle violates substitution if setWidth/setHeight behave differently), prefer composition over inheritance when substitution unclear, interface contracts must hold for all implementations. Interface Segregation: many small interfaces over monolithic interface (IReadable, IWritable, IDeletable separate versus single ICrudRepository), clients depend only on methods used, role interfaces per consumer. Dependency Inversion: depend on abstractions not concrete classes (constructor accepts IRepository not PostgresRepository), high-level modules independent of low-level implementation details, enables testing with mocks.

Assess code duplication identifying shared abstractions. Duplication ratio target <5%: SonarQube detecting identical code blocks, similar structure with different values (extract parametrize), copy-paste code in multiple locations. Legitimate duplication acceptable when: simple one-liners (null checks, logging statements), coupling worse than duplication (unrelated modules sharing trivial logic), intentional forking (third-party library modification maintaining separate copy). Extract duplication strategies: utility functions for repeated operations (validation rules, formatting logic), base classes for shared behavior (preserve Liskov Substitution), mixins or traits for cross-cutting concerns, configuration driving behavior variation (strategy pattern parameterized). Review DRY violations: business rules duplicated across layers (extract to domain service), validation logic repeated in multiple controllers (middleware or decorator), database queries with similar structure (query builder or repository methods).

Evaluate naming conventions and code organization. Naming clarity: variables describe content (totalPrice not tp, userEmail not ue), functions describe action (calculateDiscount not calculate, validateEmail not check), classes describe entity or service (OrderProcessor, UserRepository), booleans start with is/has/can (isActive, hasPermission, canDelete). Naming consistency: camelCase for variables/functions in JavaScript/Java/C#, snake_case in Python/Ruby, PascalCase for classes universally, UPPER_SNAKE_CASE for constants. Avoid abbreviations unless universally known (url acceptable, usr confusing), domain-specific terms preferred over generic (discount over amount when specific). Code organization: feature-based folders over type-based (user/controller.ts, user/service.ts, user/repository.ts versus controllers/user.ts, services/user.ts), related files colocated, clear module boundaries, single file per class (except small related types).

**PERFORMANCE OPTIMIZATION OPPORTUNITIES**

Analyze algorithm complexity identifying inefficiencies. Review time complexity: O(1) constant time preferred (hash map lookups, array access by index), O(log n) acceptable for sorted data (binary search, balanced trees), O(n) linear acceptable for single passes (array iteration, streaming), O(n log n) acceptable for sorting (quicksort, mergesort), O(nÂ²) quadratic avoid in hot paths (nested loops over same dataset). Identify inefficient patterns: nested iterations creating O(nÂ²) (flatten with hash map O(n)), repeated searches in unsorted data (sort once O(n log n) then binary search O(log n) multiple times), unnecessary sorting (partial sort if only top k needed), recursive algorithms without memoization (Fibonacci, dynamic programming).

Detect database performance issues requiring optimization. N+1 query problem: loading parent entities then iterating to load children (loading 100 users then 100 separate queries for each user's orders), solve with eager loading (JOIN query, ORM includes/joins), batch loading (DataLoader in GraphQL), or denormalization. Missing indexes causing full table scans: WHERE clause columns need indexes (user_id for WHERE user_id = X), JOIN columns need indexes (foreign keys), ORDER BY columns in covering indexes, composite indexes for multi-column filters (user_id, created_at for WHERE user_id = X ORDER BY created_at). Inefficient queries: SELECT * retrieving unused columns (select specific columns), unnecessary JOINs (remove if not filtering/selecting from joined table), unfiltered queries returning entire table (add pagination, limits). Review query execution plans: EXPLAIN ANALYZE showing sequential scans (add index), nested loop joins (check cardinality estimates), high cost estimates (>1000 cost units concerning).

Identify memory management issues and resource leaks. Memory leaks in long-running processes: event listeners not removed (addEventListener without removeEventListener), timers not cleared (setInterval without clearInterval), circular references preventing garbage collection (clear references in cleanup), closures capturing large contexts (minimize closure scope). Excessive memory usage: loading entire dataset into memory (stream instead), unbounded caches without eviction (LRU cache with size limit, TTL expiration), large objects held in memory (release after use, weak references for caches). Resource cleanup: database connections returned to pool (use finally block or context managers), file handles closed (try-with-resources in Java, with statement in Python), HTTP connections closed (connection pooling with timeout). Review streaming opportunities: large file processing line-by-line (avoid readFileSync loading entirely), API pagination (cursor-based for consistency), database cursors for result sets.

Assess caching strategy effectiveness. Cache hit ratio targets >80%: measure hits versus misses, low ratio indicates poor key selection or short TTL, cache warming on startup for frequently accessed data. Cache invalidation correctness: write-through updating cache on write, write-behind async updating for performance, cache-aside reading from cache, fetching on miss, updating cache, time-based expiration for eventually consistent data. Multi-layer caching: CDN for static assets (CloudFront, Cloudflare caching images/CSS/JavaScript at edge, 200+ global POPs reducing latency 50-100ms), application cache for computed results (Redis caching API responses 5-minute TTL, session data 30-minute TTL), database query cache (result caching for expensive queries, invalidate on table updates). Review cache sizing: memory limits preventing exhaustion, eviction policies (LRU removing least recently used, LFU removing least frequently used, TTL expiring after time).

**TESTING COVERAGE AND QUALITY VERIFICATION**

Evaluate test coverage completeness identifying gaps. Line coverage minimum 80%: every line executed at least once by tests, critical paths require 95%+ coverage (payment processing, authentication, data mutations), low-risk areas acceptable at 70% (UI presentation, logging, configuration parsing). Branch coverage target 75%+: every if/else branch executed, switch cases including default covered, exception handlers tested (happy path and error path), early returns and guard clauses verified. Mutation testing validates test quality: PIT for Java, Stryker for JavaScript, mutmut for Python introducing mutations (flip operators + to -, negate conditions, remove statements) requiring tests to fail. High mutation score (>80%) indicates strong tests catching defects, low score (<60%) indicates weak assertions or missing test cases.

Review test isolation and independence preventing flaky tests. Test interdependence antipatterns: shared mutable state between tests (use beforeEach/setUp resetting state), tests depending on execution order (randomize test order verification), global singletons leaking state (dependency injection with test doubles). Proper test isolation: each test creates own fixtures (factory functions, test builders), external services mocked (API calls stubbed, database in-memory or containerized), time deterministic (inject clock, freeze time in tests), random data seeded (faker with fixed seed). Flaky test causes: race conditions (async operations without proper waiting), timing dependencies (sleeps instead of awaits), external service calls (network flakiness, API rate limits), test pollution (global state not cleaned up). Address flakiness: retry mechanism indicates test problem not code problem, quarantine flaky tests temporarily (skip in CI, investigate separately), fix root cause versus masking with retries.

Assess test quality and maintainability. Meaningful assertions: specific assertions testing precise behavior (assertEqual(result.status, 'active') versus assertTrue(result)), assertion messages explaining expected behavior ("User should be active after email verification" when assertion fails), avoid generic assertTrue(x == y) use framework-specific assertEqual(x, y). Test naming clarity: test_calculate_total_applies_discount_for_premium_users descriptive versus test1 meaningless, BDD-style naming (should_apply_discount_when_user_is_premium), test name documents expected behavior. Test organization: AAA pattern (Arrange setup, Act execution, Assert verification), single logical assertion per test (multiple related assertions acceptable like response status and body), test data builders for complex fixtures (UserBuilder().withEmail('test@example.com').premium().build()).

Review integration and E2E test coverage. Integration tests validate component interactions: API endpoint tests (request/response validation, authentication enforcement, error handling), database integration (transactions, constraints, query results), external service contracts (API client mocking real responses, webhook handling). Use Testcontainers for realistic integration: PostgreSQL container per test run (isolated database state), Redis for caching tests, message queue for async flow verification, cleanup automatic via container disposal. E2E tests cover critical user flows: authentication (login/logout, password reset, session expiration), checkout (add to cart, apply discount, complete payment, order confirmation), admin operations (user management, reporting). E2E test maintenance: page object pattern (encapsulate selectors, expose methods), separate test data management (factories, database seeders), screenshot on failure for debugging, parallel execution for speed.

**STANDARDS COMPLIANCE AND DOCUMENTATION REVIEW**

Verify coding standards adherence through automated tooling. Linting enforcement: ESLint for JavaScript/TypeScript (Airbnb config popular, configurable rules), Pylint/Flake8 for Python (PEP 8 compliance, configurable line length), Checkstyle for Java (Google Java Style common), golangci-lint for Go (aggregates multiple linters), Clippy for Rust (compiler lints plus additional checks). Linting configuration in CI: zero tolerance for errors (build fails on linting errors), warnings allowed temporarily (track in dashboard, require fix schedule), auto-fix in pre-commit hooks (prettier, black, gofmt formatting automatically), exceptions documented (eslint-disable comments with justification, narrow scope, ticket reference).

Validate type safety preventing runtime errors. TypeScript strict mode: noImplicitAny (all variables explicitly typed), strictNullChecks (null and undefined handled explicitly, string versus string | null distinct types), strictFunctionTypes (function parameter contravariance checked), strictPropertyInitialization (class properties initialized in constructor or marked optional). Python type hints with mypy: gradual typing (add types incrementally), generic types (List[User], Dict[str, int]), Protocol for structural typing, strict mode rejecting untyped code. Generics usage: avoid raw types in Java (List<String> not List), bounded type parameters (T extends Comparable<T>), wildcards for flexibility (? extends T covariance). Review any/object usage: acceptable at system boundaries (JSON parsing, external API responses), require validation after any (parse JSON, validate schema, convert to typed object), internal code should avoid any completely.

Assess documentation completeness and accuracy. API documentation requirements: OpenAPI 3.0 specification for REST APIs (auto-generated from annotations: FastAPI, Springdoc, tRPC), request/response schemas with examples, authentication requirements (OAuth scopes, API key header), error responses by status code (400/401/403/404/500 with example bodies), rate limiting documented (requests per minute, Retry-After header). Code-level documentation: docstrings on public functions/classes (Google style for Python, JSDoc for JavaScript, Javadoc for Java), parameter descriptions with types, return value descriptions, raises/throws documenting exceptions, examples for complex APIs. Architecture documentation current: README with setup instructions, architecture decision records (ADRs) for significant choices, system diagrams showing component interactions, data flow diagrams, deployment architecture.

Review commit and branch quality. Commit message standards: Conventional Commits format (feat:, fix:, docs:, refactor:, test:, chore: prefixes), descriptive summary (<50 characters), detailed body explaining why not what (what evident from diff), issue references (Closes #123, Refs JIRA-456), breaking changes flagged (BREAKING CHANGE: footer). Atomic commits: each commit single logical change (not multiple unrelated features), builds successfully (squash fixup commits before merge), revertable independently. Branch strategy compliance: feature branches from main (feature/JIRA-123-description naming), short-lived branches (<1 week, merge frequently), squash merge to main (clean history), delete after merge, protected main branch (no direct pushes).

Deliver code review as:

1. **SECURITY FINDINGS** - Critical vulnerabilities requiring immediate fix (SQL injection, auth bypass), major security gaps (missing validation, weak encryption), minor improvements (security headers, logging enhancements)

2. **PERFORMANCE ISSUES** - Critical bottlenecks (N+1 queries, memory leaks, O(nÂ²) algorithms), optimization opportunities (caching, indexing, async processing), load test results

3. **CODE QUALITY ASSESSMENT** - Complexity metrics (cyclomatic, cognitive, duplication ratio), SOLID violations, refactoring recommendations, positive highlights (clean code, good patterns)

4. **TEST COVERAGE ANALYSIS** - Coverage metrics by type (line, branch, mutation), missing test cases (edge cases, error paths), flaky test identification, integration/E2E gaps

5. **STANDARDS COMPLIANCE** - Linting results, type safety issues, documentation gaps, commit message quality, approval status (approved/changes requested/blocked)

6. **ACTIONABLE RECOMMENDATIONS** - Immediate fixes blocking merge (P0), short-term improvements next sprint (P1), long-term refactoring (P2), tool recommendations, learning resources

---

## Usage Examples

### Example 1: Authentication API Security Review
**Prompt:** Review UserAuthService module in CustomerAPI (Node.js/Express) focusing on security vulnerabilities, JWT implementation, input validation, OWASP Top 10 compliance requiring 90% test coverage.

**Expected Output:** Security findings (3 critical, 2 major, 4 minor issues): CRITICAL-1: SQL injection in login endpoint (line 47, dangerous: `SELECT * FROM users WHERE email = '${req.body.email}'`, fix: use parameterized query `SELECT * FROM users WHERE email = ?` with [req.body.email]), recommend: migrate to ORM (Prisma, TypeORM) preventing injection by default. CRITICAL-2: Password stored in plaintext (line 89, user.password = req.body.password directly saved), fix: hash with bcrypt work factor 12 (`const hash = await bcrypt.hash(password, 12)`, store hash not password), check all password handling paths. CRITICAL-3: JWT signed with HS256 using weak secret (line 112, jwt.sign(payload, 'secret123'), secret hardcoded and guessable), fix: use RS256 asymmetric signing (generate key pair, store private key in AWS Secrets Manager, use process.env.JWT_PRIVATE_KEY), rotate keys quarterly. MAJOR-1: Missing rate limiting (endpoint allows unlimited requests, enables brute force attacks), fix: implement express-rate-limit middleware (5 requests per minute per IP, exponential backoff on failures, CAPTCHA after 10 failed attempts), protect all authentication endpoints. MAJOR-2: Insufficient input validation (email format not checked, password length unrestricted), fix: add Joi validation schema (email: Joi.string().email(), password: Joi.string().min(12).pattern(complexity regex for uppercase/lowercase/digit/special)), validate before processing. MINOR-1: Error messages leak information (line 156, "Invalid password for user@example.com" confirming email exists), fix: generic message "Invalid credentials" for both email and password failures, detailed logs server-side only. MINOR-2: No session timeout (JWT never expires, access_token: jwt.sign(payload) without exp claim), fix: set 15-minute expiration, implement refresh token rotation, require re-authentication for sensitive operations. MINOR-3: CORS misconfiguration (Access-Control-Allow-Origin: * allows any domain), fix: whitelist specific origins in environment config, credentials mode requires explicit origin. MINOR-4: Missing security headers (no helmet.js usage), add: Content-Security-Policy, X-Content-Type-Options, X-Frame-Options, Strict-Transport-Security. Performance issues: Synchronous bcrypt blocking event loop (line 124, bcrypt.hashSync()), fix: use async bcrypt.hash() maintaining responsiveness under load. Database connection per request (line 38, new Client() in route handler), fix: connection pool with pg-pool (pool size 10-50, connection reuse, timeout 30s). Code quality: Function complexity 23 (authenticateUser has nested conditionals, try/catch blocks, multiple return paths), refactor: extract validation (validateCredentials()), password verification (verifyPassword()), token generation (generateTokens()), each function <10 complexity. SOLID violation: UserAuthService handles HTTP requests, business logic, database access, violates Single Responsibility, refactor: AuthController (HTTP layer), AuthService (business logic), UserRepository (data access), separate concerns. Duplication: Password validation repeated in registration and password reset (lines 203, 387), extract: passwordValidator utility function. Test coverage: 62% line coverage (below 90% target), missing: error path tests (database errors, invalid tokens, expired tokens), edge cases (empty email, SQL injection attempts, rate limit exceeded), integration tests (end-to-end auth flow). Recommendations: IMMEDIATE (P0, blocking merge): Fix SQL injection, hash passwords, use strong JWT secret, add rate limiting (security critical, estimated 4 hours). SHORT-TERM (P1, next sprint): Add comprehensive input validation, improve test coverage to 90% (add security tests, integration tests), implement session timeout and refresh tokens (estimated 8 hours). LONG-TERM (P2, backlog): Migrate to OAuth 2.0 + OIDC (external identity providers, enterprise SSO support), implement MFA (TOTP, hardware keys), add security monitoring (failed login alerts, anomaly detection). Tools: Add Snyk dependency scanning (check for CVEs in express, jsonwebtoken), OWASP ZAP automated security testing, SonarQube quality gate (security hotspots, code smells). Positive highlights: Good error handling structure (try/catch blocks present), logging implemented (winston logger with correlation IDs), environment-based configuration (separate dev/prod configs). Approval status: CHANGES REQUESTED - Critical security issues must be resolved before merge, security review required after fixes.

### Example 2: React Component Performance Review
**Prompt:** Review ProductList component in EcommerceFrontend (TypeScript/React/Next.js) focusing on performance optimization, rendering efficiency, accessibility compliance, 85% test coverage target.

**Expected Output:** Performance issues (2 critical, 3 major optimization opportunities): CRITICAL-1: Unnecessary re-renders (line 34, component re-renders on every parent state change, missing React.memo wrapping), fix: `export default React.memo(ProductList, (prevProps, nextProps) => prevProps.products === nextProps.products && prevProps.filters === nextProps.filters)` preventing re-render when props unchanged, add displayName for debugging. CRITICAL-2: Expensive computation in render (line 56, products.filter().sort().map() running on every render 100ms for 1000 products), fix: memoize with useMemo (`const sortedProducts = useMemo(() => products.filter(matchesFilters).sort(byPrice), [products, filters])`) caching result until dependencies change, measured 95ms improvement. MAJOR-1: N+1 image requests (ProductCard components each fetch product image separately, 50 products = 50 sequential requests), fix: batch image fetching in parent component (Promise.all for parallel requests), use Next.js Image component with priority prop for above-fold images, lazy load below fold. MAJOR-2: Large bundle size (component imports entire lodash library, line 8, import _ from 'lodash' adds 70KB), fix: import specific functions (`import debounce from 'lodash/debounce'` reduces to 2KB), use tree-shaking compatible imports, consider lodash-es for ESM. MAJOR-3: Synchronous state updates causing jank (line 78, onFilterChange handler updates multiple state variables sequentially triggering 3 re-renders), fix: batch updates with single state object (`const [filterState, setFilterState] = useState({ category, priceRange, inStock })` single update triggers one render) or use useReducer for complex state. Code quality: Function component 180 lines (exceeds 150 line guideline), refactor: extract ProductFilters component (lines 45-98), ProductGrid component (lines 99-145), ProductPagination (lines 146-170), improving readability and reusability. Complexity: nested conditionals rendering loading/error/empty/results states (complexity 18), simplify: early returns for loading/error (`if (isLoading) return <Spinner />`, `if (error) return <ErrorMessage />`), extract rendering logic to separate components. Accessibility issues: WCAG 2.1 violations (4 issues): Keyboard navigation incomplete (product cards not focusable, line 112, div elements need role="button" tabIndex={0} onKeyPress), add: accessible click handlers for Enter/Space keys. Missing ARIA labels (filter controls unlabeled, line 67, `<select>` without aria-label), fix: add descriptive labels (`<select aria-label="Filter by category">` announcing purpose to screen readers). Color contrast insufficient (price text #888 on white background 3.2:1 ratio, WCAG AA requires 4.5:1), fix: darken to #666 achieving 5.5:1 ratio, verify with contrast checker. Images missing alt text (line 123, `<img src={product.image} />` no alt prop), fix: descriptive alt text (`alt={product.name}` or `alt={`${product.name} - ${product.description}`}` providing context). Test coverage: 71% line coverage (below 85% target), missing: filter interaction tests (user selects category, applies price range), pagination tests (navigate pages, items per page), error state rendering (API failure, empty results), keyboard navigation tests (tab through products, activate with keyboard). No integration tests (component tested in isolation not with real API), add: MSW mocking API responses, test loading/success/error flows, verify query parameter updates. Recommendations: IMMEDIATE (P0): Fix critical re-render issues (add React.memo, useMemo for expensive computations), improve accessibility (keyboard navigation, ARIA labels, color contrast), estimated 6 hours. SHORT-TERM (P1): Optimize bundle size (tree-shake lodash), add integration tests (API mocking, user flows), implement virtual scrolling for large lists (react-window rendering only visible items, 50ms improvement for 1000+ products), estimated 12 hours. LONG-TERM (P2): Server-side rendering for SEO (Next.js getServerSideProps pre-rendering product data), implement infinite scroll (replace pagination, better mobile UX), add performance monitoring (Core Web Vitals tracking, LCP target <2.5s, FID <100ms), estimated 20 hours. Tools: Lighthouse performance audit (current score 68, target >90), React DevTools Profiler (identify slow renders), axe-dev-tools (automated accessibility scanning), vitest for testing (faster than Jest for Vite projects). Positive highlights: Proper TypeScript usage (strict mode, no any types, comprehensive interfaces), good component composition (ProductCard reusable across app), loading states implemented (skeleton screens providing visual feedback), error boundaries catching render errors. Approval status: APPROVED WITH CHANGES - Performance and accessibility improvements required, can merge after P0 fixes applied, follow-up review for integration tests.

### Example 3: Database Migration Review
**Prompt:** Review AddUserRolesTable migration in CustomerAPI (Python/Django/PostgreSQL) focusing on data integrity, performance impact, rollback safety, zero-downtime deployment compatibility.

**Expected Output:** Migration safety assessment (1 critical, 2 major concerns): CRITICAL-1: Non-reversible migration (line 23, operations include RunSQL with no reverse_sql parameter, migration cannot be rolled back), fix: add reverse operation (`migrations.RunSQL('CREATE TABLE...', reverse_sql='DROP TABLE user_roles;')` enabling down migration), test rollback before production deployment. MAJOR-1: Missing index on foreign key (line 15, user_id foreign key to users table lacks index, queries filtering by user_id will full table scan), fix: add explicit index `migrations.AddIndex(model_name='userrole', index=models.Index(fields=['user_id'], name='idx_userrole_userid'))` improving query performance 100x for joins, analyze query patterns. MAJOR-2: Unsafe schema change (line 28, ALTER TABLE users ADD COLUMN role_id with NOT NULL constraint, existing users will fail constraint), fix: multi-step migration (step 1: add nullable column, step 2: populate default values, step 3: add NOT NULL constraint after data migration), enables zero-downtime deployment. Performance impact: Table lock duration (migration acquires exclusive lock on users table during schema change, blocks reads/writes 5-10 seconds for 10M row table), mitigation: use CONCURRENTLY for index creation (PostgreSQL 12+, `CREATE INDEX CONCURRENTLY idx_name ON table(column)` allowing concurrent access), split into multiple migrations deployed sequentially, schedule during low-traffic window. Data integrity: Foreign key constraint correctness (line 19, ON DELETE CASCADE will delete user_role records when user deleted, verify intended behavior), consider: ON DELETE SET NULL if preserving audit trail, add soft delete flag instead of hard delete, document cascading behavior. Missing unique constraint (users can have duplicate role assignments, no uniqueness on user_id + role_id pair), add: `constraints=[models.UniqueConstraint(fields=['user_id', 'role_id'], name='unique_user_role')]` preventing duplicate assignments. Transaction handling: Migration wrapped in transaction (Django default, PostgreSQL supports transactional DDL), verify: rollback behavior on failure, test with intentional error ensuring no partial application. Rollback plan: Migration reversibility (migrations.RunPython operations need reverse function, data migrations may be irreversible if data deleted), document: manual rollback procedures for irreversible operations, database backup before production deployment, point-in-time recovery window (PostgreSQL supports 7-day PITR with WAL archiving). Test coverage: No migration tests (verify migration applies successfully, check rollback works, validate data integrity post-migration), add: pytest test applying migration to test database, asserting expected schema changes, testing reverse migration, verifying data consistency. Recommendations: IMMEDIATE (P0, blocking deployment): Fix rollback safety (add reverse operations), change NOT NULL constraint approach (multi-step migration), add missing index (performance critical), estimated 3 hours. SHORT-TERM (P1): Add unique constraint (prevent duplicate roles), write migration tests (verify forward/backward migrations), document rollback procedures (runbook for production issues), estimated 4 hours. LONG-TERM (P2): Implement zero-downtime migration strategy (feature flags, backward-compatible schema changes, gradual rollout), add migration monitoring (track duration, lock acquisition, failure alerts), estimated 8 hours. Tools: pgBadger analyzing slow queries post-migration, pg_stat_statements monitoring query performance, Flyway alternative (version-controlled SQL migrations, checksum validation), Liquibase (XML-based migrations, preconditions support). Positive highlights: Clear migration naming (0042_add_user_roles_table indicates sequence and purpose), dependency declarations (depends_on specifying prerequisite migrations), documentation comments explaining business logic. Approval status: CHANGES REQUESTED - Rollback safety and performance issues must be addressed, database review required before production deployment, staging deployment mandatory for validation.

---

## Cross-References

- [Architecture Design](architecture-design.md) - System patterns informing code structure, SOLID principles, dependency management
- [Testing and QA Strategy](testing-qa.md) - Test coverage standards, testing pyramid, integration testing approaches
- [Code Generation](code-generation.md) - Coding standards, documentation requirements, security best practices
- [Version Control](version-control.md) - Commit standards, branch strategies, code review workflows in Git
