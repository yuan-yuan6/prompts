---
category: technology
title: Technical Documentation Strategy
tags:
- technical-documentation
- api-docs
- developer-guides
- system-specs
use_cases:
- Creating comprehensive API documentation with OpenAPI specifications, authentication flows, request/response examples, and error handling
- Writing developer guides including setup instructions, coding standards, testing guidelines, and contribution workflows
- Documenting system architecture with component diagrams, data flow, security design, and deployment strategies
related_templates:
- technology/architecture-design.md
- technology/code-generation.md
- technology/testing-qa.md
industries:
- finance
- government
- manufacturing
- retail
- technology
type: framework
difficulty: comprehensive
slug: software-documentation
---

# Technical Documentation Strategy

## Purpose
Create production-quality technical documentation including API references (OpenAPI/Swagger), developer guides, system architecture, operations manuals, and user documentation achieving clarity, accuracy, and maintainability for diverse technical audiences.

## Template

Create {DOCUMENTATION_TYPE} for {PROJECT_NAME} v{VERSION} targeting {TARGET_AUDIENCE} using {DOC_PLATFORM} with {REVIEW_FREQUENCY} update cycle achieving {QUALITY_STANDARD} quality.

**API DOCUMENTATION STRUCTURE AND STANDARDS**

Design API documentation following OpenAPI 3.0 specification enabling interactive exploration. Define API metadata: title and version (PaymentAPI v2.1, semantic versioning), base URL with environment variants (production https://api.company.com/v2, staging https://staging.api.company.com/v2, sandbox for testing), authentication schemes (OAuth 2.0 with authorization_code flow, API keys via X-API-Key header, JWT Bearer tokens with 15-minute expiration), global security requirements applying to all endpoints or marked optional per operation. Organize endpoints by tags grouping related operations: users tag containing registration/login/profile endpoints, payments for transactions, webhooks for callbacks enabling sidebar navigation in Swagger UI.

Document each endpoint comprehensively providing actionable information. Endpoint path with parameters: /users/{userId}/orders using path parameter userId (required, UUID format), query parameters for filtering/pagination (limit=20, offset=0, status=completed, sortBy=created_at), header parameters (Accept-Language for localization, X-Request-ID for tracing). Request body schema using JSON Schema or component reference: {amount: {type: number, minimum: 0.01}, currency: {type: string, enum: ['USD', 'EUR', 'GBP']}, description: {type: string, maxLength: 255, nullable: true}} with examples showing realistic data not placeholder values. Response specifications per status code: 200 successful GET returning {data: User, meta: {requestId, timestamp}}, 201 for resource creation with Location header, 400 bad request with validation errors {error: {code: 'INVALID_INPUT', message: 'Email format invalid', fields: [{field: 'email', message: 'Must be valid email'}]}}, 401 unauthorized, 403 forbidden, 404 not found, 500 internal server error with generic message (no stack traces exposed).

Include comprehensive code examples demonstrating integration. Provide curl commands showing actual usage: curl -X POST https://api.company.com/v2/payments -H "Authorization: Bearer $TOKEN" -H "Content-Type: application/json" -d '{"amount": 19.99, "currency": "USD"}', SDKs for multiple languages (JavaScript fetch/axios, Python requests, Go http.Client, Java OkHttp), error handling patterns (retry with exponential backoff, parse error codes, display user-friendly messages). Document rate limiting clearly: 1000 requests per minute per API key (HTTP 429 when exceeded, Retry-After header indicating wait time, upgrade tiers for higher limits), pagination patterns (cursor-based for consistency /users?cursor=abc123&limit=50 with next_cursor in response, offset-based simpler /users?offset=100&limit=50), versioning strategy (URL path /v1/, /v2/ deprecating v1 six months after v2 release with warning headers).

**DEVELOPER GUIDE ORGANIZATION**

Structure developer onboarding enabling quick starts and deep dives. Getting started section walks through first integration: prerequisites (Node.js 18+, Git, API key from dashboard), installation steps numbered clearly (1. Clone repository, 2. npm install, 3. Copy .env.example to .env, 4. Run database migrations npm run migrate, 5. Start development server npm run dev), first API call tutorial showing authentication and basic request achieving success within 10 minutes, common troubleshooting (port already in use, database connection failed, authentication errors).

Document development environment setup comprehensively. Required tools with version specifications: Node.js 18+ LTS (specify 18.17.0 minimum for feature compatibility), Docker 20.10+ and Docker Compose 2.0+ for local services (PostgreSQL, Redis, Kafka), VS Code recommended with extensions (ESLint, Prettier, REST Client for API testing), optional but helpful (Postman/Insomnia, pgAdmin for database inspection). Environment configuration via .env file: DATABASE_URL connection string, JWT_SECRET for token signing (generate securely with openssl rand -hex 32), API_PORT default 3000, LOG_LEVEL (debug in development, info in production), feature flags for experimental features. Local development workflow: start dependencies via docker-compose up -d, run migrations ensuring database schema current, seed test data npm run db:seed, start application with hot reload, run tests watching for changes npm test -- --watch.

Define coding standards enforcing consistency. Language-specific guidelines: JavaScript/TypeScript using ESLint with Airbnb config (2-space indentation, single quotes, trailing commas, semicolons required), Prettier for automatic formatting (line length 100, prose wrap always), TypeScript strict mode enabled (noImplicitAny, strictNullChecks, strictFunctionTypes preventing common errors). Architecture patterns: feature-based folder structure (users/controller.ts, users/service.ts, users/repository.ts, users/__tests__ colocating related code), dependency injection for testability (constructor injection, avoid service locator antipattern), error handling strategy (custom error classes extending base AppError, global error middleware formatting responses, no swallowed exceptions). Code review requirements: all changes via pull request (no direct commits to main), minimum 1 approval from code owner (2 for critical paths), automated checks must pass (linting, type checking, tests, security scans), descriptive PR descriptions explaining why not just what, link to related issue or design document.

**ARCHITECTURE DOCUMENTATION AND DIAGRAMS**

Present system architecture using C4 model providing multiple abstraction levels. Context diagram shows system in environment: external users (customers, administrators, partners), external systems (payment processors, email service, analytics platform), high-level capabilities (process orders, manage inventory, send notifications), technology-agnostic focusing on business context. Container diagram reveals runtime applications: web application (React SPA), mobile app (React Native), API gateway (Kong), backend services (user service, order service, payment service, notification service each in container), databases (PostgreSQL user DB, MongoDB product catalog, Redis cache), message broker (Kafka for async events). Component diagram decomposes individual containers: order service containing OrderController (handles HTTP requests), OrderService (business logic), OrderRepository (data access), EventPublisher (sends domain events), each component one responsibility.

Document data flow through system illuminating transformations. Request flow: client request to API gateway → authentication middleware validates JWT → rate limiting checks quota → routes to order service → validates input against schema → calls payment service via gRPC → publishes OrderCreated event to Kafka → returns response, all steps numbered with timing estimates (authentication 5ms, validation 10ms, payment processing 200ms, event publishing 50ms, total p95 <300ms). Event-driven flows: OrderCreated event published → inventory service consumes and reserves stock → shipping service consumes and calculates costs → notification service consumes and emails customer → analytics service consumes for reporting, eventual consistency acknowledged (inventory updated asynchronously within 5 seconds). Data persistence patterns: write-through caching (update database and cache atomically), cache-aside reading (check Redis, fetch from PostgreSQL on miss, populate cache with 5-minute TTL), event sourcing for audit trail (store all domain events, rebuild state by replaying).

Specify security architecture implementing defense in depth. Network security: VPC isolating resources (public subnet for load balancers, private subnet for application servers, isolated subnet for databases), security groups whitelist specific ports (443 for HTTPS, 5432 for PostgreSQL within VPC only), API Gateway with WAF blocking common attacks (SQL injection, XSS, rate limiting per IP). Authentication and authorization: OAuth 2.0 authorization code flow (redirects to identity provider, exchanges code for token, validates token signature and expiration), JWT access tokens short-lived 15 minutes (stored in memory, transmitted via Authorization Bearer header), refresh tokens rotating on use (stored securely httpOnly cookie or native keychain, invalidated on logout), role-based access control (admin/manager/user roles, permissions per operation checked at API and service layers). Data protection: encryption at rest using AES-256 (database encrypted with customer-managed keys rotated quarterly, file storage encrypted server-side), encryption in transit via TLS 1.3 (certificate pinning for mobile apps, HTTPS mandatory enforced by HSTS headers), field-level encryption for sensitive PII (credit cards tokenized, SSN encrypted with separate key, PHI encrypted before database storage).

**OPERATIONS AND RUNBOOK DOCUMENTATION**

Create operational runbooks enabling reliable system management. Monitoring setup: Prometheus scraping metrics from /metrics endpoint (RED metrics: request rate, error rate, duration for each endpoint, custom business metrics: active users, revenue, conversion rates), Grafana dashboards per service (request latency p50/p95/p99, error rate by status code, throughput requests per second, resource utilization CPU/memory), alerts configured in AlertManager (page on-call for p95 latency >500ms sustained 5 minutes, error rate >1% triggering immediate investigation, disk space <20% warning, <10% critical). Health checks: liveness probe /health/live returning 200 if application alive (Kubernetes restarts pod on failure, checks database connection, cache availability, critical dependencies), readiness probe /health/ready returning 503 if not ready to serve traffic (removes from load balancer during deployments, rolling updates with zero downtime).

Document backup and recovery procedures preventing data loss. Backup schedule: automated daily full backups at 2am UTC (PostgreSQL pg_dump, point-in-time recovery enabled, 30-day retention), hourly incremental backups (replication lag <30 seconds, write-ahead log archiving), cross-region replication to disaster recovery site (asynchronous replication, 1-hour RPO acceptable). Restoration testing: monthly restore drills (restore previous day backup to staging environment, verify data integrity, measure restoration time currently 45 minutes for 100GB database), documented restoration procedures (step-by-step commands, expected output at each step, rollback plan if restoration fails). Disaster recovery: RTO 4 hours (acceptable downtime for failover), RPO 1 hour (maximum data loss acceptable), failover tested quarterly (initiate failover, verify application functionality, measure actual RTO/RPO, document improvements).

Provide troubleshooting guides addressing common issues. Performance problems: high latency >500ms (check database slow query log, verify cache hit ratio, profile application with APM tool identifying bottleneck, check for N+1 query problems), high memory usage >80% (generate heap dump, analyze with profiler, check for memory leaks, verify object lifecycle), CPU spikes >80% (review recent deployments, check for infinite loops or inefficient algorithms, sample flame graphs identifying hot code paths). Connection issues: database connection pool exhausted (increase pool size from 20 to 50, analyze connection leaks, verify connections properly closed, check for long-running transactions), external API timeouts (verify network connectivity, check third-party status page, implement circuit breaker preventing cascade failures, add exponential backoff retry). Application errors: authentication failures (verify JWT not expired, check secret key matches, validate audience and issuer claims), validation errors (check request matches schema, verify required fields present, examine error response for specific validation failures), unexpected errors (check application logs for stack traces, correlation ID tracks request through services, recent deployments or configuration changes).

**DOCUMENTATION MAINTENANCE AND QUALITY**

Establish documentation-as-code workflow maintaining accuracy. Version control: documentation in Git repository alongside code (docs/ folder, Markdown files, diagrams as code using Mermaid or PlantUML), branch per documentation update (feature/update-api-docs, documentation changes reviewed like code), automated deployment (merge to main triggers static site generation, deployed to docs.company.com via Netlify/Vercel). Review process: technical accuracy review by subject matter expert (developer who built feature validates examples and descriptions), editorial review for clarity (technical writer improves readability, consistency, grammar), automated checks (broken link detection, code syntax highlighting, OpenAPI schema validation).

Define update procedures keeping documentation current. Synchronization with code: API documentation generated from OpenAPI spec in codebase (single source of truth, code changes automatically update docs, prevents drift), inline code comments become API documentation (JSDoc, Javadoc, docstrings extracted during build), changelog auto-generated from commit messages (conventional commits enabling categorization by type: feat/fix/docs). Deprecation handling: deprecate features minimum 6 months before removal (add Deprecated: true to OpenAPI operation, warning headers in API responses, migration guide published immediately), sunset headers indicating removal date (Sunset: Sat, 31 Dec 2024 23:59:59 GMT RFC 8594 standard), redirect legacy documentation URLs preventing 404 errors.

Measure documentation effectiveness through analytics. Usage metrics: page views identifying popular topics (troubleshooting visited 10x more than architecture indicating common confusion), search queries revealing gaps (frequent searches for "rate limiting" suggest missing or unclear documentation), bounce rate high indicating irrelevance or poor navigation. Feedback collection: thumbs up/down on each page (Was this page helpful? Yes/No), comment boxes for specific issues, support ticket correlation (tickets referencing documentation failures or inaccuracies), user testing sessions (watch developers attempt first integration, identify friction points). Continuous improvement: quarterly documentation review (update outdated content, add missing examples, reorganize confusing sections), feedback triage in backlog (prioritize issues causing support tickets, assign to technical writers or developers), success metrics (reduced time to first successful API call, decreased documentation-related support tickets, improved developer satisfaction scores).

Deliver technical documentation as:

1. **API REFERENCE** - OpenAPI 3.0 specification with Swagger UI, authentication flows, all endpoints documented, request/response examples, error codes, rate limits

2. **DEVELOPER GUIDE** - Setup instructions (prerequisites, installation, configuration), code standards (linting, formatting, patterns), testing guidelines (unit/integration/E2E), contribution workflow

3. **ARCHITECTURE DOCUMENTATION** - System overview, C4 model diagrams (context/container/component), data flow, security architecture, deployment topology, scalability design

4. **OPERATIONS MANUAL** - Monitoring setup (Prometheus/Grafana dashboards), health checks, backup/recovery procedures, scaling playbooks, troubleshooting guides, incident response

5. **USER DOCUMENTATION** - Getting started tutorial, feature guides, FAQ, troubleshooting, support contact information, video walkthroughs for complex features

6. **MAINTENANCE ARTIFACTS** - Documentation repository, automated deployment pipeline, review checklist, update procedures, analytics dashboard, feedback tracking system

---

## Usage Examples

### Example 1: REST API Documentation (PaymentAPI)
**Prompt:** Create API documentation for PaymentAPI v2.1 targeting external developers using OpenAPI 3.0 with comprehensive endpoint coverage and code examples.

**Expected Output:** API specification: OpenAPI 3.0 defining PaymentAPI v2.1, base URLs (production: https://api.payments.com/v2, sandbox: https://sandbox.payments.com/v2 for testing), authentication via OAuth 2.0 Bearer tokens (authorization_code flow, client credentials for server-to-server, token endpoint /oauth/token returning access_token valid 3600 seconds, refresh tokens rotating on use). Endpoints documented: POST /payments creating payment (request schema: {amount: number minimum 0.01, currency: string enum USD/EUR/GBP, paymentMethod: string required, customer: {email, name}, metadata: object optional for custom fields}, response 201: {id: UUID, status: pending/completed/failed, amount, currency, createdAt: ISO8601 timestamp}, errors: 400 invalid amount, 401 unauthorized, 403 insufficient permissions, 422 payment method declined), GET /payments/{paymentId} retrieving payment details, GET /payments list with pagination (query params: limit default 20 max 100, starting_after cursor for pagination, created_gte/created_lte filtering by date range, status for filtering), POST /refunds creating refund (paymentId, amount optional for partial, reason enum: duplicate/fraudulent/requested_by_customer), webhooks documented (POST callback URL on events: payment.succeeded, payment.failed, refund.created sending {id, type, data, created} signed with HMAC-SHA256 for verification). Authentication examples: curl obtaining token (curl -X POST https://api.payments.com/oauth/token -d grant_type=client_credentials -d client_id=$CLIENT_ID -d client_secret=$CLIENT_SECRET returning {access_token, token_type: Bearer, expires_in: 3600}), authenticated request (curl -H "Authorization: Bearer $TOKEN" https://api.payments.com/v2/payments). SDKs provided: JavaScript (npm install @payments/sdk, const client = new PaymentsClient(apiKey), await client.payments.create({amount: 1999, currency: 'USD'})), Python (pip install payments-sdk, client = PaymentsClient(api_key), client.payments.create(amount=1999, currency='USD')), error handling (try/except catching PaymentError, accessing error.code and error.message, implementing retry with exponential backoff for network errors). Rate limiting: 1000 requests/minute per API key (HTTP 429 when exceeded, response headers: X-RateLimit-Limit: 1000, X-RateLimit-Remaining: 547, X-RateLimit-Reset: 1640000000 Unix timestamp, Retry-After: 60 seconds until reset), upgrade to 10K/min for business tier. Versioning: URL path versioning /v1/ and /v2/ coexisting, v1 deprecated with Sunset header (Sunset: Sat, 30 Jun 2025 23:59:59 GMT), migration guide v1 to v2 (breaking changes: response envelope structure changed from {data} to {data, meta}, error format RFC 7807 Problem Details, pagination cursor-based versus offset). Error responses: standardized format {type: '/errors/invalid-request', title: 'Invalid Request', status: 400, detail: 'Amount must be positive number', instance: '/payments', errors: [{field: 'amount', code: 'invalid', message: 'Must be >= 0.01'}]}, documented codes (invalid-request, authentication-failed, insufficient-permissions, resource-not-found, rate-limit-exceeded, internal-error). Testing: sandbox environment (test card numbers: 4242424242424242 success, 4000000000000002 declined, 4000000000009995 insufficient funds), webhook testing (ngrok for local development, test events sent via dashboard, signature verification sample code), Postman collection (pre-configured requests, environment variables, automated tests validating responses).

### Example 2: Developer Guide (E-commerce Platform)
**Prompt:** Write developer guide for ShopPlatform backend targeting new team members with setup, coding standards, testing, and contribution workflow.

**Expected Output:** Getting started: Prerequisites (Node.js 18.17+, Docker 20.10+, Kubernetes 1.25+ for local development with kind, VS Code recommended, Postman for API testing, PostgreSQL client psql), repository setup (git clone https://github.com/company/shop-platform, cd shop-platform, npm install installing dependencies including Prisma ORM, Fastify web framework, Jest for testing), environment configuration (.env.example copied to .env, DATABASE_URL=postgresql://user:pass@localhost:5432/shopdb, JWT_SECRET generated with openssl rand -base64 32, STRIPE_SECRET_KEY from dashboard, AWS_ACCESS_KEY_ID for S3 file uploads, REDIS_URL for caching). Local development: start services (docker-compose up -d starting PostgreSQL, Redis, LocalStack for AWS, MailHog for email testing), run migrations (npx prisma migrate deploy applying all migrations, npx prisma db seed loading test data including 100 products, 50 customers, 200 orders), start application (npm run dev with nodemon for hot reload, listens on http://localhost:3000, health check at /health returning 200 {status: ok, database: connected, cache: connected}), verify setup (curl http://localhost:3000/api/v1/products listing products, npm test running full test suite should pass, check logs for errors). Architecture overview: folder structure (src/api/routes defining endpoints, src/services containing business logic, src/repositories for data access, src/models Prisma schemas, src/utils helper functions, src/middleware auth/logging/error-handling, tests/__tests__ mirroring src structure), dependency injection (services injected via constructor, repositories abstracted behind interfaces, facilitates testing with mocks). Coding standards: ESLint configuration (@company/eslint-config extending Airbnb, strict TypeScript rules: no implicit any, strict null checks, unused variables error), Prettier (2-space indentation, single quotes, trailing commas all, semicolons required, max line length 100, format on save in VS Code), naming conventions (camelCase for variables/functions, PascalCase for classes/types, UPPER_SNAKE_CASE for constants, files match export name: UserService.ts exports UserService class). Code organization: feature-based folders (products/ProductController.ts, products/ProductService.ts, products/ProductRepository.ts, products/__tests__), single responsibility (controller handles HTTP, service contains business logic, repository accesses database), async/await (prefer over callbacks, handle errors with try/catch, avoid floating promises), error handling (custom error classes: ValidationError, NotFoundError, UnauthorizedError, global error middleware formats responses, never swallow exceptions). Testing guidelines: unit tests with Jest (80% coverage target, tests colocated with code, mock dependencies with jest.mock, use describe/it blocks, test positive and negative cases), integration tests (Supertest for API endpoints, Testcontainers for PostgreSQL, test complete request/response cycle, verify database state changes), E2E tests (Playwright for critical user journeys: product search, add to cart, checkout, payment, order confirmation), TDD encouraged (write test first, implement minimal code to pass, refactor while keeping tests green). Git workflow: branch naming (feature/add-product-search, fix/cart-total-calculation, docs/api-reference), commit messages (Conventional Commits: feat: add product search with filters, fix: correct cart total calculation, docs: update API reference, breaking changes noted in footer: BREAKING CHANGE: API response structure changed), pull requests (create from feature branch, request review from code owner via CODEOWNERS, all CI checks must pass: linting, type checking, tests 80%+ coverage, security scan with Snyk, describe changes and include screenshots for UI changes), code review (approve requires resolving all conversations, suggest improvements without blocking nit:, distinguish required changes from preferences, provide context for feedback explaining why), merge (squash and merge creating single commit, PR title becomes commit message, branch auto-deleted after merge). Troubleshooting: common issues (port 3000 already in use: lsof -i :3000 finding process, kill or change PORT in .env, database connection refused: verify Docker container running docker ps, check DATABASE_URL credentials, permission denied on /var/run/docker.sock: add user to docker group), debugging (VS Code debugger configured in .vscode/launch.json, attach to Node process, set breakpoints in TypeScript, use DEBUG=* for verbose logs from all modules, inspect requests/responses in Postman).

### Example 3: Architecture Documentation (Microservices Platform)
**Prompt:** Document architecture for CloudCommerce microservices platform targeting technical architects with system overview, component diagrams, data flow, security, and deployment.

**Expected Output:** System context: CloudCommerce serves online retailers (10K merchants, 10M end customers), integrates with external systems (payment processors Stripe/PayPal, shipping carriers FedEx/UPS, email service SendGrid, SMS gateway Twilio, analytics platform Segment), provides capabilities (product catalog management, order processing, inventory tracking, customer management, marketing campaigns, analytics reporting). Container architecture: frontend web application (React SPA hosted on Vercel CDN, server-side rendering with Next.js for SEO, communicates with API gateway via HTTPS), mobile apps (React Native iOS/Android, offline mode with SQLite, push notifications via Firebase Cloud Messaging), API gateway (Kong providing rate limiting, authentication, routing to backend services, WebSocket support for real-time features), backend services (user-service managing authentication/profiles, product-service catalog with 100K SKUs, order-service processing 50K orders daily, payment-service integrating Stripe, inventory-service tracking stock levels, notification-service emails and SMS, analytics-service event processing, search-service Elasticsearch for product search), data stores (PostgreSQL for transactional data with read replicas, MongoDB for product catalog with flexible schemas, Redis for caching and sessions, Elasticsearch for search, Kafka for event streaming), monitoring (Prometheus scraping metrics, Grafana dashboards, Jaeger distributed tracing, ELK stack for logging). Component breakdown order-service: OrderController (Fastify routes handling POST /orders, GET /orders/{id}, PATCH /orders/{id}/status, validates input with Zod schemas, returns standardized responses), OrderService (business logic: createOrder validates inventory, calculates totals, calls payment service, publishes OrderCreated event, processRefund checks order status, calls payment service refund, updates order, handles errors), OrderRepository (Prisma ORM accessing PostgreSQL, findById, findByCustomerId, create, update methods, database transactions for consistency), EventPublisher (publishes domain events to Kafka: OrderCreated, OrderShipped, OrderCancelled with payload and metadata), PaymentClient (gRPC client calling payment-service, circuit breaker with Resilience4j, retry with exponential backoff, timeout 5 seconds). Data flow create order: customer submits order via web app → API gateway authenticates JWT → routes to order-service → validates product availability with inventory-service gRPC call → creates order record in PostgreSQL → calls payment-service to charge customer → publishes OrderCreated event to Kafka → inventory-service consumes event and reserves stock → shipping-service consumes and calculates costs → notification-service consumes and emails customer → returns order confirmation to customer, total time p95 <500ms. Security architecture: network isolation (Kubernetes network policies restricting pod-to-pod communication, services in private subnets, API gateway in DMZ), authentication (OAuth 2.0 authorization server, JWT access tokens 15-minute expiration, refresh tokens rotating, API keys for server-to-server), authorization (RBAC with roles: customer/merchant/admin, permissions defined in OPA policies, enforced at API gateway and service level), data protection (encryption at rest AES-256 with AWS KMS, TLS 1.3 in transit, field-level encryption for PII, PCI DSS compliance for payment data tokenized by Stripe), secrets management (AWS Secrets Manager for API keys and credentials, automatic rotation, Kubernetes secrets for non-sensitive config, no secrets in code or logs). Deployment architecture: Kubernetes on AWS EKS (3 availability zones for high availability, autoscaling node groups t3.xlarge instances, dedicated node pools for stateful workloads), container images (Docker multi-stage builds, base image hardened, scanned with Trivy, pushed to ECR with semantic version tags), deployment strategy (rolling updates with zero downtime, max unavailable 25%, readiness probes ensure traffic only to ready pods, blue-green for database migrations), service mesh (Istio providing mTLS, traffic management, observability, circuit breakers, retries, timeout policies declared in VirtualService CRDs). Scalability design: horizontal pod autoscaling (HPA based on CPU >70% or custom metrics like request queue depth, scale from 3 to 50 pods, Cluster Autoscaler adds nodes as needed), database scaling (read replicas for read-heavy services, connection pooling with PgBouncer, caching with Redis reducing database load 60%), event-driven async processing (Kafka partitions enabling parallel consumption, consumer groups for load distribution, backpressure handling with buffering). Performance characteristics: API latency p99 <200ms for GET requests, p99 <500ms for POST/PUT (database writes), throughput 10K requests/second sustained (load tested with k6), database queries p95 <50ms (indexed, analyzed with EXPLAIN), cache hit ratio >85% for product data. Reliability measures: 99.9% uptime SLA (43 minutes downtime per month), circuit breakers preventing cascade failures (half-open after 30 seconds, trip threshold 50% errors over 10 seconds), retry policies (3 attempts with exponential backoff: 100ms, 200ms, 400ms, jitter added), health checks (liveness probes restart unhealthy pods, readiness probes remove from load balancer during deployments), disaster recovery (cross-region failover to us-west-2, RTO 4 hours, RPO 1 hour, quarterly DR drills).

---

## Cross-References

- [Architecture Design](architecture-design.md) - System patterns, component design, security architecture informing documentation structure
- [Code Generation](code-generation.md) - Coding standards, API design, testing guidelines documented in developer guide
- [Testing and QA Strategy](testing-qa.md) - Testing approaches, coverage requirements, quality standards referenced in docs
- [API Documentation Best Practices](../api-design-patterns.md) - OpenAPI specification, endpoint design, versioning strategies
